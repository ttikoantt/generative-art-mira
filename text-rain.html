<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Text Rain - Mira</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            position: relative;
        }

        .container {
            text-align: center;
            z-index: 10;
            padding: 20px;
        }

        h1 {
            color: white;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            }
            to {
                text-shadow: 0 0 30px rgba(255, 255, 255, 0.8), 0 0 40px rgba(255, 255, 255, 0.6);
            }
        }

        .info {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
            margin-bottom: 20px;
        }

        canvas {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            height: auto;
            touch-action: none;
        }

        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 15px 20px;
            border-radius: 50px;
            font-size: 1.5rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
            z-index: 100;
        }

        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <button class="fullscreen-btn" onclick="toggleFullscreen()">â›¶</button>

    <div class="container">
        <h1>ğŸŒ§ï¸ Animated Text Rain</h1>
        <p class="info">æ–‡å­—ãŸã¡ãŒé›¨ã®ã‚ˆã†ã«é™ã‚Šæ³¨ã...</p>
        <canvas id="canvas"></canvas>
        <div class="controls">
            <button class="btn" onclick="changeMode()">ãƒ¢ãƒ¼ãƒ‰å¤‰æ›´</button>
            <button class="btn" onclick="changeColors()">è‰²å¤‰æ›´</button>
            <button class="btn" onclick="changeSpeed()">é€Ÿåº¦å¤‰æ›´</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºè¨­å®š
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 40, 800);
            const maxHeight = Math.min(window.innerHeight - 300, 600);
            canvas.width = maxWidth;
            canvas.height = maxHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // è¨­å®š
        let mode = 0; // 0: ã²ã‚‰ãŒãª, 1: ã‚«ã‚¿ã‚«ãƒŠ, 2: æ¼¢å­—, 3: çµµæ–‡å­—
        const modes = ['ã²ã‚‰ãŒãª', 'ã‚«ã‚¿ã‚«ãƒŠ', 'æ¼¢å­—', 'çµµæ–‡å­—'];

        const characterSets = {
            hiragana: 'ã‚ã„ã†ãˆãŠã‹ããã‘ã“ã•ã—ã™ã›ããŸã¡ã¤ã¦ã¨ãªã«ã¬ã­ã®ã¯ã²ãµã¸ã»ã¾ã¿ã‚€ã‚ã‚‚ã‚„ã‚†ã‚ˆã‚‰ã‚Šã‚‹ã‚Œã‚ã‚ã‚’ã‚“',
            katakana: 'ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿ãƒãƒ„ãƒ†ãƒˆãƒŠãƒ‹ãƒŒãƒãƒãƒãƒ’ãƒ•ãƒ˜ãƒ›ãƒãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ¦ãƒ¨ãƒ©ãƒªãƒ«ãƒ¬ãƒ­ãƒ¯ãƒ²ãƒ³',
            kanji: 'æ—¥æœˆç«æ°´æœ¨é‡‘åœŸå±±å·ç”°äººæœ¬ç›®åŠ›æ‰‹å£è¶³è€³å¿ƒçŸ³é›¨é¢¨é›²èŠ±é³¥è™«é­šé¦¬ç‰›çŠ¬çŒ«',
            emoji: 'â­ğŸŒŸâœ¨ğŸ’«âš¡ğŸ”¥ğŸ’§ğŸŒ¸ğŸŒºğŸŒ»ğŸŒ·ğŸŒ¹ğŸ€ğŸŒ²ğŸŒ³ğŸŒ´ğŸŒµğŸŒ¾ğŸŒ¿â˜˜ï¸ğŸğŸ‚ğŸƒâ„ï¸â›„'
        };

        let colorScheme = 0;
        const colorSchemes = [
            ['#ff006e', '#8338ec', '#3a86ff', '#06ffa5'],
            ['#f72585', '#7209b7', '#3a0ca3', '#4361ee'],
            ['#ffbe0b', '#fb5607', '#ff006e', '#8338ec'],
            ['#00f5d4', '#00bbf9', '#00a6fb', '#0582ca'],
            ['#ffffff', '#cccccc', '#999999', '#666666']
        ];

        let speed = 1;
        const speeds = [0.5, 1, 1.5, 2];
        let speedIndex = 1;

        // ãƒ†ã‚­ã‚¹ãƒˆã®é›¨ç²’
        class RainDrop {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * -canvas.height;
                this.speed = (Math.random() * 2 + 1) * speed;
                this.text = this.getRandomChar();
                this.size = Math.random() * 20 + 16;
                this.color = this.getRandomColor();
                this.opacity = Math.random() * 0.5 + 0.5;
                this.rotation = (Math.random() - 0.5) * 0.3;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02;
            }

            getRandomChar() {
                let chars;
                switch(mode) {
                    case 0: chars = characterSets.hiragana; break;
                    case 1: chars = characterSets.katakana; break;
                    case 2: chars = characterSets.kanji; break;
                    case 3: chars = characterSets.emoji; break;
                }
                return chars[Math.floor(Math.random() * chars.length)];
            }

            getRandomColor() {
                const colors = colorSchemes[colorScheme];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            update() {
                this.y += this.speed;
                this.rotation += this.rotationSpeed;

                // æ™‚ã€…æ–‡å­—ã‚’å¤‰æ›´
                if (Math.random() < 0.02) {
                    this.text = this.getRandomChar();
                }

                // ç”»é¢å¤–ã«å‡ºãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
                if (this.y > canvas.height + 50) {
                    this.reset();
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                ctx.font = `${this.size}px "Courier New", monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, 0, 0);

                // ã‚°ãƒ­ãƒ¼åŠ¹æœ
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.fillText(this.text, 0, 0);

                ctx.restore();
            }
        }

        // é›¨ç²’ã®é…åˆ—
        const drops = [];
        const numDrops = 150;

        for (let i = 0; i < numDrops; i++) {
            const drop = new RainDrop();
            drop.y = Math.random() * canvas.height; // åˆæœŸä½ç½®ã¯ç”»é¢å…¨ä½“ã«
            drops.push(drop);
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drops.forEach(drop => {
                drop.update();
                drop.draw();
            });

            requestAnimationFrame(animate);
        }

        animate();

        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«é–¢æ•°
        function changeMode() {
            mode = (mode + 1) % 4;
            drops.forEach(drop => {
                drop.text = drop.getRandomChar();
            });
        }

        function changeColors() {
            colorScheme = (colorScheme + 1) % colorSchemes.length;
            drops.forEach(drop => {
                drop.color = drop.getRandomColor();
            });
        }

        function changeSpeed() {
            speedIndex = (speedIndex + 1) % speeds.length;
            speed = speeds[speedIndex];
        }

        // å…¨ç”»é¢è¡¨ç¤º
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // ã‚¿ãƒƒãƒæ“ä½œå¯¾å¿œ
        let lastTouchTime = 0;
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const now = Date.now();
            if (now - lastTouchTime < 300) {
                // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—
                const touch = e.touches[0];
                for (let i = 0; i < 10; i++) {
                    const drop = new RainDrop();
                    drop.x = touch.clientX - canvas.getBoundingClientRect().left;
                    drop.y = touch.clientY - canvas.getBoundingClientRect().top;
                    drop.speed = Math.random() * 3 + 2;
                    drops.push(drop);
                }
                if (drops.length > 200) {
                    drops.splice(0, 10);
                }
            }
            lastTouchTime = now;
        });

        // ãƒã‚¦ã‚¹æ“ä½œ
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            for (let i = 0; i < 10; i++) {
                const drop = new RainDrop();
                drop.x = x + (Math.random() - 0.5) * 50;
                drop.y = y + (Math.random() - 0.5) * 50;
                drop.speed = Math.random() * 3 + 2;
                drops.push(drop);
            }
            if (drops.length > 200) {
                drops.splice(0, 10);
            }
        });
    </script>
</body>
</html>
