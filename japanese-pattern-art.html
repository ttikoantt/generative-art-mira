<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å’ŒæŸ„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚¢ãƒ¼ãƒˆ | Japanese Pattern Art</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Hiragino Mincho ProN", "Yu Mincho", serif;
            background: #1a1a2e;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #eee;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            text-align: center;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 20px;
            text-align: center;
        }

        .canvas-container {
            background: #0f0f1a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
        }

        canvas {
            display: block;
            border-radius: 8px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            max-width: 600px;
        }

        button {
            padding: 12px 24px;
            font-size: 0.9rem;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: "Hiragino Mincho ProN", "Yu Mincho", serif;
        }

        .pattern-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .pattern-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .action-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(245, 87, 108, 0.4);
        }

        .info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            text-align: center;
            font-size: 0.85rem;
            color: #aaa;
            max-width: 500px;
        }

        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.5rem;
            }

            .canvas-container {
                padding: 10px;
            }

            button {
                padding: 10px 18px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <button class="fullscreen-btn" onclick="toggleFullscreen()">â›¶</button>

    <h1>å’ŒæŸ„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚¢ãƒ¼ãƒˆ</h1>
    <p class="subtitle">Japanese Traditional Pattern Generator</p>

    <div class="canvas-container">
        <canvas id="canvas" width="500" height="500"></canvas>
    </div>

    <div class="controls">
        <button class="pattern-btn" onclick="setPattern('asanoha')">éº»ã®è‘‰</button>
        <button class="pattern-btn" onclick="setPattern('seigaiha')">é’æµ·æ³¢</button>
        <button class="pattern-btn" onclick="setPattern('shippo')">ä¸ƒå®</button>
        <button class="pattern-btn" onclick="setPattern('ichimatsu')">å¸‚æ¾æ¨¡æ§˜</button>
        <button class="pattern-btn" onclick="setPattern('sayagata')">ç´—ç¶¾å½¢</button>
        <button class="action-btn" onclick="regenerate()">ğŸ”„ å†ç”Ÿæˆ</button>
    </div>

    <div class="info">
        <strong>å’ŒæŸ„ã®ç¨®é¡</strong>: éº»ã®è‘‰ï¼ˆé­”é™¤ã‘ï¼‰ã€é’æµ·æ³¢ï¼ˆå¹³ç©ï¼‰ã€ä¸ƒå®ï¼ˆå††æº€ï¼‰ã€å¸‚æ¾ï¼ˆç¹æ „ï¼‰ã€ç´—ç¶¾å½¢ï¼ˆæ°¸é ï¼‰
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let currentPattern = 'asanoha';
        let seed = Math.random() * 10000;

        // Resize canvas for mobile
        function resizeCanvas() {
            const maxSize = Math.min(window.innerWidth - 40, 500);
            canvas.width = maxSize;
            canvas.height = maxSize;
            draw();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function setPattern(pattern) {
            currentPattern = pattern;
            draw();
        }

        function regenerate() {
            seed = Math.random() * 10000;
            draw();
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Random color palette
            const hue1 = (seed * 137) % 360;
            const hue2 = (hue1 + 180) % 360;
            const color1 = `hsl(${hue1}, 70%, 55%)`;
            const color2 = `hsl(${hue2}, 70%, 55%)`;
            const color3 = `hsl(${(hue1 + 90) % 360}, 60%, 60%)`;

            switch(currentPattern) {
                case 'asanoha':
                    drawAsanoha(color1, color2, color3);
                    break;
                case 'seigaiha':
                    drawSeigaiha(color1, color2, color3);
                    break;
                case 'shippo':
                    drawShippo(color1, color2, color3);
                    break;
                case 'ichimatsu':
                    drawIchimatsu(color1, color2);
                    break;
                case 'sayagata':
                    drawSayagata(color1, color2);
                    break;
            }
        }

        // éº»ã®è‘‰ (Asanoha) - Hemp leaf pattern
        function drawAsanoha(c1, c2, c3) {
            const size = canvas.width / 6;
            const time = Date.now() / 3000;

            for (let x = 0; x < 6; x++) {
                for (let y = 0; y < 6; y++) {
                    const cx = x * size + size / 2;
                    const cy = y * size + size / 2;
                    const phase = (x + y) * 0.3;

                    // Hexagon
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2 - Math.PI / 6;
                        const r = size * 0.45;
                        const px = cx + Math.cos(angle) * r;
                        const py = cy + Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.strokeStyle = c1;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Leaf-like lines
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2 - Math.PI / 6;
                        const r = size * 0.4;
                        ctx.lineTo(cx + Math.cos(angle) * r, cy + Math.sin(angle) * r);
                    }
                    ctx.strokeStyle = c2;
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Inner triangles
                    for (let i = 0; i < 6; i++) {
                        const angle1 = (i / 6) * Math.PI * 2 - Math.PI / 6;
                        const angle2 = ((i + 1) / 6) * Math.PI * 2 - Math.PI / 6;
                        const r = size * 0.25;

                        ctx.beginPath();
                        ctx.moveTo(cx, cy);
                        ctx.lineTo(cx + Math.cos(angle1) * r, cy + Math.sin(angle1) * r);
                        ctx.lineTo(cx + Math.cos(angle2) * r, cy + Math.sin(angle2) * r);
                        ctx.closePath();
                        ctx.fillStyle = i % 2 === 0 ? c3 : c1;
                        ctx.globalAlpha = 0.3;
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                }
            }
        }

        // é’æµ·æ³¢ (Seigaiha) - Blue wave pattern
        function drawSeigaiha(c1, c2, c3) {
            const waveWidth = canvas.width / 4;
            const waveHeight = canvas.height / 3;
            const time = Date.now() / 2000;

            for (let row = 0; row < 3; row++) {
                for (let col = -1; col < 5; col++) {
                    const offsetX = (row % 2) * waveWidth / 2;
                    const cx = col * waveWidth + offsetX;
                    const cy = row * waveHeight;

                    ctx.beginPath();
                    const waveCount = 3;
                    for (let i = 0; i <= waveCount; i++) {
                        const t = i / waveCount;
                        const x = cx + t * waveWidth;
                        const baseY = cy + waveHeight * 0.7;
                        const waveY = Math.sin(t * Math.PI * 2 + time + row) * waveHeight * 0.3;

                        if (i === 0) ctx.moveTo(x, baseY + waveY);
                        else {
                            const cp1x = cx + ((i - 1) / waveCount + 0.5 / waveCount) * waveWidth;
                            const cp1y = baseY + waveHeight * 0.5;
                            const cp2x = cx + (t - 0.5 / waveCount) * waveWidth;
                            const cp2y = baseY + waveHeight * 0.5;
                            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, baseY + waveY);
                        }
                    }

                    // Close the wave
                    ctx.lineTo(cx + waveWidth, cy);
                    ctx.lineTo(cx, cy);
                    ctx.closePath();

                    const gradient = ctx.createRadialGradient(
                        cx + waveWidth / 2, cy + waveHeight / 2, 0,
                        cx + waveWidth / 2, cy + waveHeight / 2, waveWidth * 0.7
                    );
                    gradient.addColorStop(0, c1);
                    gradient.addColorStop(0.5, c2);
                    gradient.addColorStop(1, c3);

                    ctx.fillStyle = gradient;
                    ctx.globalAlpha = 0.4;
                    ctx.fill();
                    ctx.globalAlpha = 1;

                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }

        // ä¸ƒå® (Shippo) - Seven treasures pattern
        function drawShippo(c1, c2, c3) {
            const circleSize = canvas.width / 5;
            const radius = circleSize * 0.45;

            for (let x = -1; x < 6; x++) {
                for (let y = -1; y < 6; y++) {
                    const cx = x * circleSize + circleSize / 2;
                    const cy = y * circleSize + circleSize / 2;

                    // Main circle
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = c1;
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Inner pattern
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius * 0.7, 0, Math.PI * 2);
                    ctx.strokeStyle = c2;
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Flower petals inside
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
                        ctx.beginPath();
                        ctx.ellipse(
                            cx + Math.cos(angle) * radius * 0.35,
                            cy + Math.sin(angle) * radius * 0.35,
                            radius * 0.25,
                            radius * 0.15,
                            angle,
                            0,
                            Math.PI * 2
                        );
                        ctx.fillStyle = i % 2 === 0 ? c3 : c1;
                        ctx.globalAlpha = 0.5;
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }

                    // Center dot
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius * 0.1, 0, Math.PI * 2);
                    ctx.fillStyle = c2;
                    ctx.fill();
                }
            }
        }

        // å¸‚æ¾æ¨¡æ§˜ (Ichimatsu) - Checkered pattern
        function drawIchimatsu(c1, c2) {
            const size = canvas.width / 6;
            const time = Date.now() / 5000;

            for (let x = 0; x < 6; x++) {
                for (let y = 0; y < 6; y++) {
                    const isFilled = (x + y) % 2 === 0;
                    const brightness = Math.sin(time + x * 0.3 + y * 0.3) * 0.1 + 0.9;

                    ctx.fillStyle = isFilled ? c1 : c2;
                    ctx.globalAlpha = brightness * 0.8;
                    ctx.fillRect(x * size, y * size, size, size);

                    // Add subtle pattern
                    if (isFilled) {
                        ctx.beginPath();
                        ctx.arc(x * size + size / 2, y * size + size / 2, size * 0.15, 0, Math.PI * 2);
                        ctx.fillStyle = c2;
                        ctx.globalAlpha = 0.3;
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
            }

            // Grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 6; i++) {
                ctx.beginPath();
                ctx.moveTo(i * size, 0);
                ctx.lineTo(i * size, canvas.height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * size);
                ctx.lineTo(canvas.width, i * size);
                ctx.stroke();
            }
        }

        // ç´—ç¶¾å½¢ (Sayagata) - Key fret pattern
        function drawSayagata(c1, c2) {
            const unitSize = canvas.width / 6;
            const swastikaSize = unitSize * 0.7;

            for (let x = 0; x < 6; x++) {
                for (let y = 0; y < 6; y++) {
                    const cx = x * unitSize + unitSize / 2;
                    const cy = y * unitSize + unitSize / 2;
                    const s = swastikaSize / 2;

                    // Background square
                    ctx.fillStyle = (x + y) % 2 === 0 ? c1 : 'transparent';
                    ctx.globalAlpha = 0.2;
                    ctx.fillRect(x * unitSize, y * unitSize, unitSize, unitSize);
                    ctx.globalAlpha = 1;

                    // Swastika-like pattern (å - Buddhist symbol of eternity)
                    ctx.strokeStyle = c2;
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';

                    // Vertical and horizontal bars
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - s);
                    ctx.lineTo(cx, cy - s * 0.3);
                    ctx.moveTo(cx, cy + s * 0.3);
                    ctx.lineTo(cx, cy + s);
                    ctx.moveTo(cx - s, cy);
                    ctx.lineTo(cx - s * 0.3, cy);
                    ctx.moveTo(cx + s * 0.3, cy);
                    ctx.lineTo(cx + s, cy);
                    ctx.stroke();

                    // Diagonal arms
                    ctx.beginPath();
                    // Top-right
                    ctx.moveTo(cx + s * 0.3, cy - s);
                    ctx.lineTo(cx + s * 0.3, cy - s * 0.3);
                    ctx.lineTo(cx + s, cy - s * 0.3);
                    // Bottom-right
                    ctx.moveTo(cx + s, cy + s * 0.3);
                    ctx.lineTo(cx + s * 0.3, cy + s * 0.3);
                    ctx.lineTo(cx + s * 0.3, cy + s);
                    // Bottom-left
                    ctx.moveTo(cx - s * 0.3, cy + s);
                    ctx.lineTo(cx - s * 0.3, cy + s * 0.3);
                    ctx.lineTo(cx - s, cy + s * 0.3);
                    // Top-left
                    ctx.moveTo(cx - s, cy - s * 0.3);
                    ctx.lineTo(cx - s * 0.3, cy - s * 0.3);
                    ctx.lineTo(cx - s * 0.3, cy - s);
                    ctx.stroke();

                    // Center dot
                    ctx.beginPath();
                    ctx.arc(cx, cy, s * 0.15, 0, Math.PI * 2);
                    ctx.fillStyle = c1;
                    ctx.fill();
                }
            }
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // Initial draw
        draw();

        // Animate slowly
        setInterval(() => {
            draw();
        }, 50);
    </script>
</body>
</html>
