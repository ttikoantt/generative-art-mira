<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doubling Frame Animation | Mira</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            z-index: 1000;
            border-radius: 5px;
            transition: all 0.3s;
        }

        #fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        canvas {
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 50px rgba(138, 43, 226, 0.3);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            text-align: center;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
        }

        .controls button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 8px 15px;
            margin: 5px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 12px;
        }

        .controls button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <button id="fullscreen-btn">全画面表示</button>

    <div class="controls">
        <button id="reset-btn">リセット</button>
        <button id="pause-btn">一時停止</button>
    </div>

    <canvas id="canvas"></canvas>

    <div class="info">
        クリックで新しいフレーム追加 | 時間とともに進化するアニメーション
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let frames = [];
        let currentFrame = 0;
        let animationSpeed = 1;
        let isPaused = false;

        function resize() {
            width = Math.min(window.innerWidth - 40, 800);
            height = Math.min(window.innerHeight - 150, 600);
            canvas.width = width;
            canvas.height = height;
        }

        function generateFrame() {
            const frameData = {
                shapes: [],
                colors: [],
                alpha: 1
            };

            // 複数の幾何学形状を生成
            const shapeCount = 5 + Math.floor(Math.random() * 5);
            
            for (let i = 0; i < shapeCount; i++) {
                frameData.shapes.push({
                    type: ['circle', 'rect', 'triangle', 'line'][Math.floor(Math.random() * 4)],
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: 20 + Math.random() * 100,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.05
                });

                frameData.colors.push({
                    hue: Math.random() * 360,
                    saturation: 60 + Math.random() * 40,
                    lightness: 40 + Math.random() * 30
                });
            }

            frameData.alpha = 0.5 + Math.random() * 0.5;

            return frameData;
        }

        function drawShape(shape, color, alpha) {
            ctx.save();
            ctx.translate(shape.x, shape.y);
            ctx.rotate(shape.rotation);
            ctx.globalAlpha = alpha;
            
            const gradient = ctx.createRadialGradient(
                shape.x - Math.cos(shape.rotation) * shape.size / 2,
                shape.y - Math.sin(shape.rotation) * shape.size / 2,
                0,
                shape.x, shape.y, shape.size
            );
            
            gradient.addColorStop(0, `hsla(${color.hue}, ${color.saturation}%, ${color.lightness}%, 1)`);
            gradient.addColorStop(0.5, `hsla(${(color.hue + 30) % 360}, ${color.saturation}%, ${color.lightness}%, 0.8)`);
            gradient.addColorStop(1, `hsla(${(color.hue + 60) % 360}, ${color.saturation}%, ${color.lightness - 20}%, 0)`);
            
            ctx.fillStyle = gradient;
            ctx.strokeStyle = `hsla(${color.hue}, ${color.saturation}%, ${color.lightness + 20}%, 0.8)`;
            ctx.lineWidth = 2;

            switch (shape.type) {
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(0, 0, shape.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    break;
                    
                case 'rect':
                    ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size);
                    ctx.strokeRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size);
                    break;
                    
                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(0, -shape.size / 2);
                    ctx.lineTo(shape.size / 2, shape.size / 2);
                    ctx.lineTo(-shape.size / 2, shape.size / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                    
                case 'line':
                    ctx.beginPath();
                    ctx.moveTo(-shape.size, 0);
                    ctx.lineTo(shape.size, 0);
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    break;
            }

            ctx.restore();
        }

        function draw() {
            // 背景を半透明で上書き（トレイル効果）
            ctx.fillStyle = 'rgba(10, 10, 15, 0.1)';
            ctx.fillRect(0, 0, width, height);

            // 現在のフレームと前後のフレームをブレンド
            const blendFrames = 3;
            
            for (let offset = -blendFrames; offset <= blendFrames; offset++) {
                const frameIndex = (currentFrame + offset + frames.length * 100) % frames.length;
                const frame = frames[frameIndex];
                
                if (!frame) continue;

                const distanceFromCenter = Math.abs(offset);
                const blendAlpha = Math.pow(0.5, distanceFromCenter) * 0.8;

                frame.shapes.forEach((shape, i) => {
                    // 回転をアニメーション
                    shape.rotation += shape.rotationSpeed * animationSpeed;
                    
                    drawShape(shape, frame.colors[i], blendAlpha * frame.alpha);
                });
            }
        }

        function animate() {
            if (!isPaused) {
                draw();
                currentFrame = (currentFrame + animationSpeed) % frames.length;
            }
            requestAnimationFrame(animate);
        }

        function init() {
            resize();

            // 初期フレームを生成
            for (let i = 0; i < 8; i++) {
                frames.push(generateFrame());
            }

            animate();
        }

        // イベントリスナー
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 新しいフレームを追加
            const newFrame = generateFrame();
            frames.push(newFrame);

            // クリック位置の近くの図形を強調
            newFrame.shapes.forEach(shape => {
                const dx = shape.x - x;
                const dy = shape.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 150) {
                    shape.size *= 1.5;
                    shape.rotationSpeed *= 2;
                }
            });
        });

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            frames = [];
            currentFrame = 0;
            for (let i = 0; i < 8; i++) {
                frames.push(generateFrame());
            }
        });

        document.getElementById('pause-btn').addEventListener('click', (e) => {
            isPaused = !isPaused;
            e.target.textContent = isPaused ? '再開' : '一時停止';
        });

        window.addEventListener('resize', resize);

        init();
    </script>
</body>
</html>
