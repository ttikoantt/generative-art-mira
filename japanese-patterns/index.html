<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂíåÈ¢®„Ç∏„Çß„Éç„É¨„Éº„ÉÜ„Ç£„Éñ„Ç¢„Éº„Éà - Japanese Patterns</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Hiragino Kaku Gothic Pro', 'Yu Gothic', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #f0f0f0;
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            color: #ffd700;
        }

        .subtitle {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 20px;
        }

        .canvas-container {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        canvas {
            display: block;
            background: #0a0a0f;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            max-width: 500px;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .btn-primary {
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            color: #1a1a2e;
            font-weight: bold;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #f0f0f0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.1);
            color: #f0f0f0;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            backdrop-filter: blur(10px);
        }

        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.4rem;
            }
            canvas {
                width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <h1>üå∏ ÂíåÈ¢®„Ç∏„Çß„Éç„É¨„Éº„ÉÜ„Ç£„Éñ„Ç¢„Éº„Éà</h1>
    <p class="subtitle">Japanese Traditional Pattern Generator</p>

    <button class="fullscreen-btn" onclick="toggleFullscreen()">ÂÖ®ÁîªÈù¢Ë°®Á§∫</button>

    <div class="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <div class="controls">
        <button class="btn btn-primary" onclick="changePattern()">Ê®°Êßò„ÇíÂ§âÊõ¥</button>
        <button class="btn btn-secondary" onclick="changeColorScheme()">Ëâ≤„ÇíÂ§âÊõ¥</button>
        <button class="btn btn-secondary" onclick="toggleAnimation()">„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥</button>
        <button class="btn btn-secondary" onclick="download()">‰øùÂ≠ò</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        function resizeCanvas() {
            const size = Math.min(window.innerWidth - 40, 500);
            canvas.width = size;
            canvas.height = size;
            draw();
        }

        let currentPattern = 0;
        let currentColorScheme = 0;
        let animationEnabled = true;
        let animationId = null;
        let time = 0;

        // Traditional Japanese patterns
        const patterns = [
            {
                name: 'È∫ª„ÅÆËëâ (Asanoha)',
                draw: drawAsanoha
            },
            {
                name: 'ÈùíÊµ∑Ê≥¢ (Seigaiha)',
                draw: drawSeigaiha
            },
            {
                name: '‰∏ÉÂÆù (Shippo)',
                draw: drawShippo
            },
            {
                name: 'Á∂≤‰ª£ (Ajiro)',
                draw: drawAjiro
            },
            {
                name: 'Áü¢Áµ£ (Yagasuri)',
                draw: drawYagasuri
            },
            {
                name: 'È±ó (Uroko)',
                draw: drawUroko
            }
        ];

        // Color schemes inspired by traditional Japanese colors
        const colorSchemes = [
            {
                name: 'Èáë„Å®ÊºÜ',
                primary: '#ffd700',
                secondary: '#1a1a2e',
                accent: '#c9302c',
                background: '#0a0a0f'
            },
            {
                name: 'Ê°ú',
                primary: '#ffb7c5',
                secondary: '#2d3436',
                accent: '#ff6b9d',
                background: '#1a1a2e'
            },
            {
                name: 'Á´π',
                primary: '#68d89a',
                secondary: '#2d3436',
                accent: '#0652dd',
                background: '#0f1419'
            },
            {
                name: 'Á¥ÖËëâ',
                primary: '#ff6348',
                secondary: '#2d3436',
                accent: '#ffd93d',
                background: '#1a0a0a'
            },
            {
                name: 'Á¥´ÈôΩËä±',
                primary: '#a29bfe',
                secondary: '#2d3436',
                accent: '#74b9ff',
                background: '#0a0a1f'
            }
        ];

        // Asanoha (Hemp leaf) pattern
        function drawAsanoha(ctx, colors, t) {
            const size = 40;
            const rows = Math.ceil(canvas.height / size) + 1;
            const cols = Math.ceil(canvas.width / size) + 1;

            for (let row = -1; row < rows; row++) {
                for (let col = -1; col < cols; col++) {
                    const x = col * size;
                    const y = row * size;
                    const phase = (col + row) * 0.3 + t;
                    
                    ctx.strokeStyle = colors.primary;
                    ctx.lineWidth = 1.5;
                    ctx.globalAlpha = 0.6 + Math.sin(phase) * 0.4;

                    // Hexagon
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60 - 30) * Math.PI / 180;
                        const px = x + size * 0.5 * Math.cos(angle);
                        const py = y + size * 0.5 * Math.sin(angle);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();

                    // Inner star pattern
                    ctx.beginPath();
                    for (let i = 0; i < 3; i++) {
                        const angle1 = (i * 120 + 90) * Math.PI / 180;
                        const angle2 = (i * 120 + 30) * Math.PI / 180;
                        const cx = x;
                        const cy = y;
                        ctx.moveTo(cx, cy);
                        ctx.lineTo(
                            cx + size * 0.45 * Math.cos(angle1),
                            cy + size * 0.45 * Math.sin(angle1)
                        );
                        ctx.moveTo(cx, cy);
                        ctx.lineTo(
                            cx + size * 0.45 * Math.cos(angle2),
                            cy + size * 0.45 * Math.sin(angle2)
                        );
                    }
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;
        }

        // Seigaiha (Blue ocean waves) pattern
        function drawSeigaiha(ctx, colors, t) {
            const waveWidth = 60;
            const waveHeight = 40;
            const cols = Math.ceil(canvas.width / waveWidth) + 1;
            const rows = Math.ceil(canvas.height / (waveHeight * 0.5)) + 2;

            for (let row = -1; row < rows; row++) {
                for (let col = -1; col < cols; col++) {
                    const x = col * waveWidth + (row % 2) * (waveWidth / 2);
                    const y = row * waveHeight * 0.5;
                    const phase = col * 0.2 + row * 0.1 + t;

                    ctx.strokeStyle = colors.primary;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5 + Math.sin(phase) * 0.5;

                    ctx.beginPath();
                    ctx.arc(x, y, waveWidth * 0.4, Math.PI, 0);
                    ctx.stroke();

                    // Inner wave
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(x, y, waveWidth * 0.25, Math.PI, 0);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;
        }

        // Shippo (Seven treasures) pattern
        function drawShippo(ctx, colors, t) {
            const size = 50;
            const cols = Math.ceil(canvas.width / size) + 1;
            const rows = Math.ceil(canvas.height / (size * 0.866)) + 1;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * size + (row % 2) * (size / 2);
                    const y = row * size * 0.866;
                    const phase = (col + row) * 0.5 + t;

                    // Flower pattern
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * 90 + Math.sin(phase) * 10) * Math.PI / 180;
                        const radius = size * 0.35;
                        
                        ctx.fillStyle = i % 2 === 0 ? colors.primary : colors.accent;
                        ctx.globalAlpha = 0.6 + Math.sin(phase + i) * 0.4;
                        
                        ctx.beginPath();
                        ctx.arc(
                            x + radius * Math.cos(angle),
                            y + radius * Math.sin(angle),
                            size * 0.18,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }

                    // Center circle
                    ctx.fillStyle = colors.secondary;
                    ctx.globalAlpha = 1;
                    ctx.beginPath();
                    ctx.arc(x, y, size * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;
        }

        // Ajiro (Woven pattern)
        function drawAjiro(ctx, colors, t) {
            const spacing = 30;
            const cols = Math.ceil(canvas.width / spacing) + 1;
            const rows = Math.ceil(canvas.height / (spacing * 0.866)) + 1;

            ctx.lineWidth = 2;

            for (let row = -1; row < rows; row++) {
                for (let col = -1; col < cols; col++) {
                    const x = col * spacing + (row % 2) * (spacing / 2);
                    const y = row * spacing * 0.866;
                    const phase = col * 0.3 + row * 0.2 + t;

                    ctx.strokeStyle = col % 2 === 0 ? colors.primary : colors.accent;
                    ctx.globalAlpha = 0.4 + Math.sin(phase) * 0.6;

                    // Diagonal lines
                    ctx.beginPath();
                    ctx.moveTo(x - spacing, y - spacing * 0.866);
                    ctx.lineTo(x + spacing, y + spacing * 0.866);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(x + spacing, y - spacing * 0.866);
                    ctx.lineTo(x - spacing, y + spacing * 0.866);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;
        }

        // Yagasuri (Arrow feather) pattern
        function drawYagasuri(ctx, colors, t) {
            const size = 60;
            const cols = Math.ceil(canvas.width / size) + 1;
            const rows = Math.ceil(canvas.height / size) + 1;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * size + size / 2;
                    const y = row * size + size / 2;
                    const phase = (col + row) * 0.4 + t;

                    // Arrow shape
                    ctx.fillStyle = (col + row) % 3 === 0 ? colors.primary : colors.secondary;
                    ctx.globalAlpha = 0.5 + Math.sin(phase) * 0.5;

                    ctx.beginPath();
                    ctx.moveTo(x, y - size * 0.35);
                    ctx.lineTo(x + size * 0.25, y);
                    ctx.lineTo(x + size * 0.15, y);
                    ctx.lineTo(x + size * 0.15, y + size * 0.35);
                    ctx.lineTo(x - size * 0.15, y + size * 0.35);
                    ctx.lineTo(x - size * 0.15, y);
                    ctx.lineTo(x - size * 0.25, y);
                    ctx.closePath();
                    ctx.fill();

                    // Center line
                    ctx.strokeStyle = colors.accent;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y - size * 0.2);
                    ctx.lineTo(x, y + size * 0.3);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;
        }

        // Uroko (Fish scales) pattern
        function drawUroko(ctx, colors, t) {
            const size = 50;
            const cols = Math.ceil(canvas.width / size) + 1;
            const rows = Math.ceil(canvas.height / (size * 0.866)) + 2;

            for (let row = -1; row < rows; row++) {
                for (let col = -1; col < cols; col++) {
                    const x = col * size + (row % 2) * (size / 2);
                    const y = row * size * 0.866;
                    const phase = col * 0.3 + row * 0.2 + t;

                    // Scale pattern
                    ctx.fillStyle = (col + row) % 2 === 0 ? colors.primary : colors.accent;
                    ctx.globalAlpha = 0.5 + Math.sin(phase) * 0.5;

                    ctx.beginPath();
                    ctx.moveTo(x, y - size * 0.1);
                    ctx.quadraticCurveTo(x + size * 0.4, y, x, y + size * 0.4);
                    ctx.quadraticCurveTo(x - size * 0.4, y, x, y - size * 0.1);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;
        }

        function draw() {
            const colors = colorSchemes[currentColorScheme];
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            patterns[currentPattern].draw(ctx, colors, time);
        }

        function animate() {
            if (!animationEnabled) return;
            time += 0.02;
            draw();
            animationId = requestAnimationFrame(animate);
        }

        function changePattern() {
            currentPattern = (currentPattern + 1) % patterns.length;
            if (!animationEnabled) draw();
        }

        function changeColorScheme() {
            currentColorScheme = (currentColorScheme + 1) % colorSchemes.length;
            if (!animationEnabled) draw();
        }

        function toggleAnimation() {
            animationEnabled = !animationEnabled;
            if (animationEnabled) {
                animate();
            } else if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }

        function download() {
            const link = document.createElement('a');
            link.download = 'japanese-pattern.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                canvas.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }

        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        animate();

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            changePattern();
        });

        canvas.addEventListener('dblclick', () => {
            changeColorScheme();
        });
    </script>
</body>
</html>
