<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÈáèÂ≠ê„ÇÇ„Å§„Çå„Éë„Éº„ÉÜ„Ç£„ÇØ„É´</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        .container {
            text-align: center;
            width: 100%;
            max-width: 800px;
            padding: 20px;
        }

        h1 {
            color: #fff;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(138, 43, 226, 0.5);
        }

        .subtitle {
            color: #aaa;
            font-size: clamp(0.8rem, 2vw, 1rem);
            margin-bottom: 20px;
        }

        #canvas {
            border: 2px solid rgba(138, 43, 226, 0.3);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.2);
            touch-action: none;
        }

        .info {
            color: #888;
            font-size: clamp(0.7rem, 1.5vw, 0.9rem);
            margin-top: 15px;
            line-height: 1.6;
        }

        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(138, 43, 226, 0.3);
            border: 1px solid rgba(138, 43, 226, 0.5);
            color: #fff;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .fullscreen-btn:hover {
            background: rgba(138, 43, 226, 0.5);
        }

        @media (max-width: 600px) {
            .fullscreen-btn {
                top: 10px;
                right: 10px;
                padding: 8px 12px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <button class="fullscreen-btn" onclick="toggleFullscreen()">ÂÖ®ÁîªÈù¢</button>

    <div class="container">
        <h1>‚öõÔ∏è ÈáèÂ≠ê„ÇÇ„Å§„Çå„Éë„Éº„ÉÜ„Ç£„ÇØ„É´</h1>
        <p class="subtitle">Quantum Entangled Particles</p>
        <canvas id="canvas"></canvas>
        <p class="info">
            üñ±Ô∏è „Éû„Ç¶„Çπ/„Çø„ÉÉ„ÉÅ„Åß„Éë„Éº„ÉÜ„Ç£„ÇØ„É´„ÇíÊìç‰Ωú<br>
            2„Å§„ÅÆÁ≤íÂ≠ê„ÅåÈáèÂ≠ê„ÇÇ„Å§„Çå„ÅßÁµê„Å≥„Å§„ÅÑ„Å¶„ÅÑ„Åæ„Åô
        </p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Canvas size
        function resizeCanvas() {
            const container = document.querySelector('.container');
            const maxWidth = Math.min(window.innerWidth - 40, 750);
            const maxHeight = Math.min(window.innerHeight - 250, 500);
            canvas.width = maxWidth;
            canvas.height = maxHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Entangled particles
        let particle1 = { x: canvas.width * 0.3, y: canvas.height / 2, vx: 2, vy: -1 };
        let particle2 = { x: canvas.width * 0.7, y: canvas.height / 2, vx: -2, vy: 1 };
        let trails1 = [];
        let trails2 = [];
        const maxTrails = 50;
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let phase = 0;

        // Mouse tracking
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
        });

        function getParticleColor(x, y, time) {
            const hue1 = (time * 0.5 + x * 0.5) % 360;
            const hue2 = (hue1 + 180) % 360;
            return {
                c1: `hsl(${hue1}, 100%, 60%)`,
                c2: `hsl(${hue2}, 100%, 60%)`
            };
        }

        function updateParticles() {
            phase += 0.02;

            // Calculate entanglement force
            const dx = particle2.x - particle1.x;
            const dy = particle2.y - particle1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const force = Math.sin(phase) * 0.5;

            // Update particle 1 (attracted to mouse)
            const dx1 = mouseX - particle1.x;
            const dy1 = mouseY - particle1.y;
            const dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            particle1.vx += (dx1 / dist1) * 0.3 - particle1.vx * 0.02;
            particle1.vy += (dy1 / dist1) * 0.3 - particle1.vy * 0.02;

            // Entanglement effect on particle 1
            particle1.vx += (dx / dist) * force * 0.5;
            particle1.vy += (dy / dist) * force * 0.5;

            // Update particle 2 (mirror of particle 1)
            particle2.vx = -particle1.vx + Math.sin(phase * 1.3) * 2;
            particle2.vy = -particle1.vy + Math.cos(phase * 1.7) * 2;

            // Apply velocities
            particle1.x += particle1.vx;
            particle1.y += particle1.vy;
            particle2.x += particle2.vx;
            particle2.y += particle2.vy;

            // Boundary check
            const padding = 20;
            if (particle1.x < padding || particle1.x > canvas.width - padding) {
                particle1.vx *= -0.8;
                particle1.x = Math.max(padding, Math.min(canvas.width - padding, particle1.x));
            }
            if (particle1.y < padding || particle1.y > canvas.height - padding) {
                particle1.vy *= -0.8;
                particle1.y = Math.max(padding, Math.min(canvas.height - padding, particle1.y));
            }
            if (particle2.x < padding || particle2.x > canvas.width - padding) {
                particle2.vx *= -0.8;
                particle2.x = Math.max(padding, Math.min(canvas.width - padding, particle2.x));
            }
            if (particle2.y < padding || particle2.y > canvas.height - padding) {
                particle2.vy *= -0.8;
                particle2.y = Math.max(padding, Math.min(canvas.height - padding, particle2.y));
            }

            // Store trails
            trails1.push({ x: particle1.x, y: particle1.y });
            trails2.push({ x: particle2.x, y: particle2.y });
            if (trails1.length > maxTrails) trails1.shift();
            if (trails2.length > maxTrails) trails2.shift();
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const colors = getParticleColor(0, 0, phase * 50);

            // Draw entanglement line
            ctx.beginPath();
            ctx.moveTo(particle1.x, particle1.y);
            
            // Curved connection
            const midX = (particle1.x + particle2.x) / 2;
            const midY = (particle1.y + particle2.y) / 2 + Math.sin(phase * 2) * 50;
            ctx.quadraticCurveTo(midX, midY, particle2.x, particle2.y);
            
            const gradient = ctx.createLinearGradient(particle1.x, particle1.y, particle2.x, particle2.y);
            gradient.addColorStop(0, colors.c1);
            gradient.addColorStop(0.5, `rgba(255, 255, 255, 0.5)`);
            gradient.addColorStop(1, colors.c2);
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 3;
            ctx.stroke();

            // Draw trails
            for (let i = 0; i < trails1.length; i++) {
                const alpha = i / trails1.length;
                ctx.beginPath();
                ctx.arc(trails1[i].x, trails1[i].y, 3 * alpha, 0, Math.PI * 2);
                ctx.fillStyle = colors.c1.replace(')', `, ${alpha * 0.5})`).replace('hsl', 'hsla');
                ctx.fill();
            }

            for (let i = 0; i < trails2.length; i++) {
                const alpha = i / trails2.length;
                ctx.beginPath();
                ctx.arc(trails2[i].x, trails2[i].y, 3 * alpha, 0, Math.PI * 2);
                ctx.fillStyle = colors.c2.replace(')', `, ${alpha * 0.5})`).replace('hsl', 'hsla');
                ctx.fill();
            }

            // Draw particles
            // Particle 1
            ctx.beginPath();
            ctx.arc(particle1.x, particle1.y, 15, 0, Math.PI * 2);
            const grad1 = ctx.createRadialGradient(particle1.x, particle1.y, 0, particle1.x, particle1.y, 15);
            grad1.addColorStop(0, colors.c1);
            grad1.addColorStop(1, 'transparent');
            ctx.fillStyle = grad1;
            ctx.fill();

            // Particle 2
            ctx.beginPath();
            ctx.arc(particle2.x, particle2.y, 15, 0, Math.PI * 2);
            const grad2 = ctx.createRadialGradient(particle2.x, particle2.y, 0, particle2.x, particle2.y, 15);
            grad2.addColorStop(0, colors.c2);
            grad2.addColorStop(1, 'transparent');
            ctx.fillStyle = grad2;
            ctx.fill();

            // Glow effect
            ctx.beginPath();
            ctx.arc(particle1.x, particle1.y, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(particle2.x, particle2.y, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
        }

        function animate() {
            updateParticles();
            draw();
            requestAnimationFrame(animate);
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        animate();
    </script>
</body>
</html>
