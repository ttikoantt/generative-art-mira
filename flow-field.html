<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Field - Generative Art</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0a0f;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #canvas {
            border: 1px solid #1a1a2e;
            cursor: crosshair;
        }
        
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        
        button {
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            color: #64c8ff;
            padding: 10px 20px;
            font-size: 12px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        button:hover {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.5);
        }
        
        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <button class="fullscreen-btn" onclick="toggleFullscreen()">‚õ∂ Fullscreen</button>
    
    <div class="controls">
        <button onclick="reset()">‚Üª Reset</button>
        <button onclick="changeColors()">üé® Colors</button>
        <button onclick="toggleAnimation()">‚èØ Pause</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let particles = [];
        let flowField = [];
        let scale = 20;
        let rows, cols;
        let animationId;
        let isAnimating = true;
        let colorScheme = 0;
        
        const colorSchemes = [
            ['#64c8ff', '#64ffda', '#ff64c8', '#c864ff'],
            ['#ffd700', '#ff6b6b', '#4ecdc4', '#45b7d1'],
            ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3'],
            ['#a29bfe', '#fd79a8', '#00b894', '#fdcb6e']
        ];
        
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            
            cols = Math.floor(width / scale);
            rows = Math.floor(height / scale);
            
            initFlowField();
        }
        
        function initFlowField() {
            flowField = new Array(cols * rows);
            let zOff = 0;
            
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const index = x + y * cols;
                    const angle = noise(x * 0.1, y * 0.1, zOff) * Math.PI * 4;
                    flowField[index] = angle;
                }
            }
        }
        
        // „Ç∑„É≥„Éó„É´„Å™„Éé„Ç§„Ç∫Èñ¢Êï∞ÔºàÁ∞°ÊòìÁâà„Éë„Éº„É™„É≥„Éé„Ç§„Ç∫Ôºâ
        function noise(x, y, z) {
            const p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
            
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            const Z = Math.floor(z) & 255;
            
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            
            const u = fade(x);
            const v = fade(y);
            const w = fade(z);
            
            const A = p[X] + Y;
            const AA = p[A] + Z;
            const AB = p[A + 1] + Z;
            const B = p[X + 1] + Y;
            const BA = p[B] + Z;
            const BB = p[B + 1] + Z;
            
            return lerp(w,
                lerp(v,
                    lerp(u, grad(p[AA], x, y, z), grad(p[BA], x - 1, y, z)),
                    lerp(u, grad(p[AB], x, y - 1, z), grad(p[BB], x - 1, y - 1, z))
                ),
                lerp(v,
                    lerp(u, grad(p[AA + 1], x, y, z - 1), grad(p[BA + 1], x - 1, y, z - 1)),
                    lerp(u, grad(p[AB + 1], x, y - 1, z - 1), grad(p[BB + 1], x - 1, y - 1, z - 1))
                )
            );
        }
        
        function fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }
        
        function lerp(t, a, b) {
            return a + t * (b - a);
        }
        
        function grad(hash, x, y, z) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }
        
        class Particle {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.vx = 0;
                this.vy = 0;
                this.size = Math.random() * 2 + 1;
                this.speed = Math.random() * 2 + 1;
                this.life = Math.random() * 200 + 100;
                this.maxLife = this.life;
                this.color = colorSchemes[colorScheme][Math.floor(Math.random() * 4)];
            }
            
            update() {
                const x = Math.floor(this.x / scale);
                const y = Math.floor(this.y / scale);
                const index = x + y * cols;
                
                if (index >= 0 && index < flowField.length) {
                    const angle = flowField[index];
                    this.vx += Math.cos(angle) * 0.1;
                    this.vy += Math.sin(angle) * 0.1;
                }
                
                this.vx *= 0.95;
                this.vy *= 0.95;
                
                this.x += this.vx * this.speed;
                this.y += this.vy * this.speed;
                
                this.life--;
                
                if (this.life <= 0 || this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                    this.reset();
                }
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.fill();
            }
        }
        
        function initParticles() {
            particles = [];
            for (let i = 0; i < 1000; i++) {
                particles.push(new Particle());
            }
        }
        
        function animate() {
            ctx.fillStyle = 'rgba(10, 10, 15, 0.05)';
            ctx.fillRect(0, 0, width, height);
            
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            if (isAnimating) {
                animationId = requestAnimationFrame(animate);
            }
        }
        
        function reset() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, width, height);
            initFlowField();
            initParticles();
        }
        
        function changeColors() {
            colorScheme = (colorScheme + 1) % colorSchemes.length;
            particles.forEach(p => {
                p.color = colorSchemes[colorScheme][Math.floor(Math.random() * 4)];
            });
        }
        
        function toggleAnimation() {
            isAnimating = !isAnimating;
            if (isAnimating) {
                animate();
            }
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        window.addEventListener('resize', resize);
        
        resize();
        initParticles();
        animate();
    </script>
</body>
</html>
