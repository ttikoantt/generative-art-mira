<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Skyline</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0a0f;
            min-height: 100vh;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        
        canvas {
            display: block;
        }
        
        .overlay {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #0ff;
            font-size: 14px;
            text-align: center;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            z-index: 100;
            opacity: 0.8;
        }
        
        .title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff, 0 0 30px #ff00ff;
            z-index: 100;
            letter-spacing: 4px;
        }
        
        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 0, 255, 0.3);
            color: #ff00ff;
            border: 1px solid #ff00ff;
            padding: 10px 20px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 100;
            transition: all 0.3s;
        }
        
        .fullscreen-btn:hover {
            background: rgba(255, 0, 255, 0.5);
            box-shadow: 0 0 20px #ff00ff;
        }
    </style>
</head>
<body>
    <div class="title">CYBERPUNK SKYLINE</div>
    <button class="fullscreen-btn" onclick="toggleFullscreen()">FULLSCREEN</button>
    <div class="overlay">Move mouse to interact</div>
    <canvas id="canvas"></canvas>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let buildings = [];
        let neonSigns = [];
        let stars = [];
        let raindrops = [];
        let mouseX = 0;
        let time = 0;
        
        // Neon colors
        const neonColors = [
            '#ff00ff', // magenta
            '#0ff',    // cyan
            '#ff0',    // yellow
            '#f0f',    // fuchsia
            '#0f0',    // lime
            '#f00',    // red
            '#00f',    // blue
        ];
        
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            generateScene();
        }
        
        function generateScene() {
            buildings = [];
            neonSigns = [];
            stars = [];
            raindrops = [];
            
            // Generate stars
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height * 0.4,
                    size: Math.random() * 2 + 0.5,
                    twinkle: Math.random() * Math.PI * 2,
                    speed: Math.random() * 0.05 + 0.02
                });
            }
            
            // Generate buildings (parallax layers)
            const layers = [
                { speed: 0.1, count: 8, minHeight: 0.15, maxHeight: 0.35, color: '#1a1a2e' },
                { speed: 0.3, count: 12, minHeight: 0.25, maxHeight: 0.5, color: '#16213e' },
                { speed: 0.6, count: 15, minHeight: 0.35, maxHeight: 0.7, color: '#0f3460' }
            ];
            
            layers.forEach((layer, layerIndex) => {
                const buildingWidth = width / layer.count;
                
                for (let i = 0; i < layer.count; i++) {
                    const buildingHeight = height * (layer.minHeight + Math.random() * (layer.maxHeight - layer.minHeight));
                    const x = i * buildingWidth + (Math.random() - 0.5) * buildingWidth * 0.5;
                    
                    // Building windows
                    const windowRows = Math.floor(buildingHeight / 30);
                    const windowCols = Math.floor(buildingWidth / 20);
                    const windows = [];
                    
                    for (let row = 0; row < windowRows; row++) {
                        for (let col = 0; col < windowCols; col++) {
                            if (Math.random() > 0.3) {
                                windows.push({
                                    x: col * 20 + 5,
                                    y: row * 30 + 10,
                                    lit: Math.random() > 0.5,
                                    color: Math.random() > 0.7 ? neonColors[Math.floor(Math.random() * neonColors.length)] : '#ffff99',
                                    flicker: Math.random()
                                });
                            }
                        }
                    }
                    
                    buildings.push({
                        x: x,
                        width: buildingWidth * (0.8 + Math.random() * 0.4),
                        height: buildingHeight,
                        layer: layerIndex,
                        color: layer.color,
                        speed: layer.speed,
                        windows: windows
                    });
                    
                    // Add neon signs on front layer
                    if (layerIndex === 2 && Math.random() > 0.6) {
                        neonSigns.push({
                            x: x + buildingWidth * 0.2,
                            y: height - buildingHeight - 20 - Math.random() * 100,
                            text: getRandomSign(),
                            color: neonColors[Math.floor(Math.random() * neonColors.length)],
                            flicker: Math.random() * 10,
                            scale: 0.8 + Math.random() * 0.4
                        });
                    }
                }
            });
            
            // Generate rain
            for (let i = 0; i < 100; i++) {
                raindrops.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    speed: Math.random() * 10 + 5,
                    length: Math.random() * 20 + 10
                });
            }
        }
        
        function getRandomSign() {
            const signs = [
                'CYBER', 'NEON', 'TECH', 'AI', 'CODE', 'DATA', 'BYTE',
                'MATRIX', 'SYNTH', 'RETRO', 'FUTURE', '2077', 'NIGHT',
                'CITY', 'ELECTRIC', 'PULSE', 'NEURAL', 'GHOST', 'SHELL'
            ];
            return signs[Math.floor(Math.random() * signs.length)];
        }
        
        function drawSky() {
            const gradient = ctx.createLinearGradient(0, 0, 0, height * 0.6);
            gradient.addColorStop(0, '#0a0015');
            gradient.addColorStop(0.5, '#1a0030');
            gradient.addColorStop(1, '#2a1a3e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height * 0.6);
            
            // Add horizon glow
            const horizonGlow = ctx.createRadialGradient(width / 2, height * 0.6, 0, width / 2, height * 0.6, width * 0.6);
            horizonGlow.addColorStop(0, 'rgba(255, 0, 100, 0.3)');
            horizonGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = horizonGlow;
            ctx.fillRect(0, 0, width, height);
        }
        
        function drawStars() {
            stars.forEach(star => {
                star.twinkle += star.speed;
                const alpha = 0.3 + Math.sin(star.twinkle) * 0.3;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawMoon() {
            const moonX = width * 0.85 + (mouseX - width / 2) * 0.02;
            const moonY = height * 0.15;
            
            // Moon glow
            const glow = ctx.createRadialGradient(moonX, moonY, 0, moonX, moonY, 100);
            glow.addColorStop(0, 'rgba(255, 200, 255, 0.3)');
            glow.addColorStop(1, 'transparent');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(moonX, moonY, 100, 0, Math.PI * 2);
            ctx.fill();
            
            // Moon
            ctx.fillStyle = '#ffeef0';
            ctx.beginPath();
            ctx.arc(moonX, moonY, 40, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawBuildings() {
            const offsetX = (mouseX - width / 2) * 0.05;
            
            // Sort by layer (back to front)
            const sortedBuildings = [...buildings].sort((a, b) => a.layer - b.layer);
            
            sortedBuildings.forEach(building => {
                const parallaxOffset = offsetX * building.speed;
                const x = building.x + parallaxOffset;
                const y = height - building.height;
                
                // Building shadow/glow
                ctx.fillStyle = building.color;
                ctx.fillRect(x, y, building.width, building.height);
                
                // Building edge highlight
                ctx.strokeStyle = `rgba(100, 150, 255, 0.1)`;
                ctx.strokeRect(x, y, building.width, building.height);
                
                // Windows
                building.windows.forEach(win => {
                    if (win.lit) {
                        const flicker = Math.sin(time * 0.01 + win.flicker * 10) * 0.2 + 0.8;
                        ctx.fillStyle = win.color;
                        ctx.globalAlpha = flicker * 0.8;
                        ctx.fillRect(x + win.x, y + win.y, 12, 18);
                        
                        // Window glow
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = win.color;
                        ctx.fillRect(x + win.x, y + win.y, 12, 18);
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                    }
                });
            });
        }
        
        function drawNeonSigns() {
            const offsetX = (mouseX - width / 2) * 0.05;
            
            neonSigns.forEach(sign => {
                const parallaxOffset = offsetX * 0.6;
                const flicker = Math.sin(time * 0.05 + sign.flicker) * 0.3 + 0.7;
                
                ctx.save();
                ctx.translate(sign.x + parallaxOffset, sign.y);
                ctx.scale(sign.scale, sign.scale);
                
                // Glow
                ctx.shadowBlur = 30 * flicker;
                ctx.shadowColor = sign.color;
                ctx.fillStyle = sign.color;
                ctx.globalAlpha = flicker;
                ctx.font = 'bold 24px "Courier New"';
                ctx.fillText(sign.text, 0, 0);
                
                // Double glow
                ctx.shadowBlur = 60 * flicker;
                ctx.fillText(sign.text, 0, 0);
                
                ctx.restore();
            });
        }
        
        function drawRain() {
            ctx.strokeStyle = 'rgba(100, 150, 255, 0.3)';
            ctx.lineWidth = 1;
            
            raindrops.forEach(drop => {
                drop.y += drop.speed;
                if (drop.y > height) {
                    drop.y = -drop.length;
                    drop.x = Math.random() * width;
                }
                
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x - 2, drop.y + drop.length);
                ctx.stroke();
            });
        }
        
        function drawFog() {
            const gradient = ctx.createLinearGradient(0, height * 0.7, 0, height);
            gradient.addColorStop(0, 'transparent');
            gradient.addColorStop(0.5, 'rgba(100, 50, 150, 0.2)');
            gradient.addColorStop(1, 'rgba(50, 25, 75, 0.5)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, height * 0.7, width, height * 0.3);
        }
        
        function drawScanlines() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            for (let y = 0; y < height; y += 4) {
                ctx.fillRect(0, y, width, 2);
            }
        }
        
        function drawReflection() {
            // Reflect the lower portion of buildings
            ctx.globalAlpha = 0.15;
            ctx.scale(1, -0.3);
            ctx.translate(0, -height * 4);
            drawBuildings();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.globalAlpha = 1;
        }
        
        function animate() {
            time++;
            
            // Clear with slight fade for motion blur effect
            ctx.fillStyle = 'rgba(10, 10, 15, 0.3)';
            ctx.fillRect(0, 0, width, height);
            
            drawSky();
            drawStars();
            drawMoon();
            drawBuildings();
            drawNeonSigns();
            drawReflection();
            drawRain();
            drawFog();
            drawScanlines();
            
            requestAnimationFrame(animate);
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        // Event listeners
        window.addEventListener('resize', resize);
        window.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
        });
        
        // Touch support
        window.addEventListener('touchmove', (e) => {
            mouseX = e.touches[0].clientX;
        });
        
        // Initialize
        resize();
        animate();
    </script>
</body>
</html>
