<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Geometry Generator by Mira</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }

        h1 {
            color: #fff;
            font-size: 2rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .subtitle {
            color: #a0a0a0;
            font-size: 0.9rem;
            margin-bottom: 30px;
        }

        #canvas-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            background: #fff;
        }

        canvas {
            display: block;
        }

        .controls {
            margin-top: 25px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 28px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-generate {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-generate:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        .btn-save {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-save:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(245, 87, 108, 0.4);
        }

        .info {
            margin-top: 20px;
            color: #808080;
            font-size: 0.85rem;
            text-align: center;
        }

        #palette-preview {
            display: flex;
            gap: 5px;
            margin-top: 15px;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
        }

        .color-swatch {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>
    <h1>ðŸŽ¨ Random Geometry Generator</h1>
    <p class="subtitle">by Mira - Generative Art Experiment</p>

    <div id="canvas-container">
        <canvas id="canvas" width="800" height="600"></canvas>
    </div>

    <div id="palette-preview"></div>

    <div class="controls">
        <button class="btn-generate" onclick="generateArt()">âœ¨ Generate</button>
        <button class="btn-save" onclick="saveArt()">ðŸ’¾ Save</button>
    </div>

    <p class="info">Each generation creates a unique geometric composition</p>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Color palettes - carefully curated harmonious combinations
        const palettes = [
            // Sunset vibes
            ['#ff6b6b', '#feca57', '#ff9ff3', '#f368e0', '#ff9f43'],
            // Ocean depths
            ['#0abde3', '#48dbfb', '#00d2d3', '#54a0ff', '#5f27cd'],
            // Forest magic
            ['#10ac84', '#1dd1a1', '#00d2d3', '#2e86de', '#5f27cd'],
            // Neon dreams
            ['#fd79a8', '#e84393', '#a29bfe', '#6c5ce7', '#00cec9'],
            // Warm embrace
            ['#fdcb6e', '#e17055', '#d63031', '#b71540', '#ff7675'],
            // Cool elegance
            ['#74b9ff', '#0984e3', '#a29bfe', '#6c5ce7', '#dfe6e9'],
            // Earth tones
            ['#b7950b', '#7d6608', '#9a7d0a', '#7b7d7d', '#979a9a'],
            // Berry blend
            ['#e056fd', '#686de0', '#30336b', '#be2edd', '#22a6b3'],
            // Pastel dreams
            ['#ffcccc', '#ccb3ff', '#b3d9ff', '#ccffcc', '#ffffcc'],
            // Cyberpunk
            ['#00ff87', '#60efff', '#ff00ff', '#ffff00', '#ff0055']
        ];

        let currentPalette = [];
        let animationProgress = 0;
        let shapes = [];
        let animationId = null;

        // Shape types
        const SHAPE_CIRCLE = 'circle';
        const SHAPE_RECTANGLE = 'rectangle';
        const SHAPE_TRIANGLE = 'triangle';
        const SHAPE_POLYGON = 'polygon';
        const SHAPE_LINE = 'line';

        // Blend modes for interesting effects
        const blendModes = [
            'source-over',
            'multiply',
            'screen',
            'overlay',
            'darken',
            'lighten',
            'color-dodge',
            'color-burn',
            'hard-light',
            'soft-light',
            'difference',
            'exclusion'
        ];

        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function randomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randomItem(array) {
            return array[Math.floor(Math.random() * array.length)];
        }

        function selectPalette() {
            currentPalette = [...randomItem(palettes)];
            updatePalettePreview();
        }

        function updatePalettePreview() {
            const preview = document.getElementById('palette-preview');
            preview.innerHTML = '';
            currentPalette.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                preview.appendChild(swatch);
            });
        }

        function createShape() {
            const type = randomItem([
                SHAPE_CIRCLE, SHAPE_CIRCLE, SHAPE_CIRCLE,
                SHAPE_RECTANGLE, SHAPE_RECTANGLE,
                SHAPE_TRIANGLE, SHAPE_POLYGON, SHAPE_LINE
            ]);

            return {
                type,
                x: randomFloat(0, canvas.width),
                y: randomFloat(0, canvas.height),
                size: randomFloat(30, 200),
                color: randomItem(currentPalette),
                alpha: randomFloat(0.1, 0.8),
                rotation: randomFloat(0, Math.PI * 2),
                blendMode: randomItem(blendModes),
                sides: type === SHAPE_POLYGON ? randomInt(5, 8) : 3,
                thickness: randomFloat(1, 8),
                delay: randomFloat(0, 1), // Delay before appearing
                duration: randomFloat(0.5, 1.5), // Animation duration
                progress: 0
            };
        }

        function drawShape(shape, progress) {
            ctx.save();
            ctx.globalAlpha = shape.alpha * progress;
            ctx.globalCompositeOperation = shape.blendMode;

            ctx.translate(shape.x, shape.y);
            ctx.rotate(shape.rotation);

            ctx.fillStyle = shape.color;
            ctx.strokeStyle = shape.color;
            ctx.lineWidth = shape.thickness;

            const size = shape.size * progress;

            switch(shape.type) {
                case SHAPE_CIRCLE:
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    if (Math.random() > 0.5) {
                        ctx.fill();
                    } else {
                        ctx.stroke();
                    }
                    break;

                case SHAPE_RECTANGLE:
                    if (Math.random() > 0.5) {
                        ctx.fillRect(-size/2, -size/2, size, size);
                    } else {
                        ctx.strokeRect(-size/2, -size/2, size, size);
                    }
                    break;

                case SHAPE_TRIANGLE:
                    ctx.beginPath();
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 - Math.PI / 2;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    if (Math.random() > 0.5) ctx.fill();
                    else ctx.stroke();
                    break;

                case SHAPE_POLYGON:
                    ctx.beginPath();
                    for (let i = 0; i < shape.sides; i++) {
                        const angle = (i / shape.sides) * Math.PI * 2 - Math.PI / 2;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    if (Math.random() > 0.5) ctx.fill();
                    else ctx.stroke();
                    break;

                case SHAPE_LINE:
                    ctx.beginPath();
                    const angle = randomFloat(0, Math.PI * 2);
                    ctx.moveTo(
                        Math.cos(angle) * size * 1.5,
                        Math.sin(angle) * size * 1.5
                    );
                    ctx.lineTo(
                        Math.cos(angle + Math.PI) * size * 1.5,
                        Math.sin(angle + Math.PI) * size * 1.5
                    );
                    ctx.stroke();
                    break;
            }

            ctx.restore();
        }

        function animate(timestamp) {
            if (!animationProgress) {
                animationProgress = timestamp;
            }

            const elapsed = (timestamp - animationProgress) / 1000;

            // Clear canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw all shapes with their individual animation progress
            let allComplete = true;
            shapes.forEach(shape => {
                const shapeElapsed = elapsed - shape.delay;
                if (shapeElapsed < 0) {
                    allComplete = false;
                    return;
                }

                const shapeProgress = Math.min(shapeElapsed / shape.duration, 1);
                // Easing function (ease out cubic)
                const easedProgress = 1 - Math.pow(1 - shapeProgress, 3);

                if (shapeProgress < 1) {
                    allComplete = false;
                }

                drawShape(shape, easedProgress);
            });

            if (!allComplete && elapsed < 10) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function generateArt() {
            // Cancel any ongoing animation
            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            // Select new palette
            selectPalette();

            // Generate shapes
            const numShapes = randomInt(20, 40);
            shapes = [];
            for (let i = 0; i < numShapes; i++) {
                shapes.push(createShape());
            }

            // Start animation
            animationProgress = null;
            animationId = requestAnimationFrame(animate);
        }

        function saveArt() {
            const link = document.createElement('a');
            link.download = `mira-art-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // Generate initial art on load
        window.onload = generateArt;
    </script>
</body>
</html>
