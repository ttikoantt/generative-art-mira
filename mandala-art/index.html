<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generative Mandala - „Éü„É©„ÅÆ„Ç∏„Çß„Éç„É¨„Éº„ÉÜ„Ç£„Éñ„Éª„Ç¢„Éº„Éà</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }

        canvas {
            display: block;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .controls button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        .controls button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            z-index: 100;
        }

        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="info">
        <div>„Éû„Ç¶„Çπ„ÇíÂãï„Åã„Åó„Å¶„Éë„Çø„Éº„É≥„ÇíÂ§â„Åà„Çã</div>
        <div>„ÇØ„É™„ÉÉ„ÇØ„ÅßÊñ∞„Åó„ÅÑ„Éû„É≥„ÉÄ„É©ÁîüÊàê</div>
    </div>

    <div class="controls">
        <button id="randomBtn">üé≤ „É©„É≥„ÉÄ„É†ÁîüÊàê</button>
        <button id="saveBtn">üíæ ‰øùÂ≠ò</button>
    </div>

    <button class="fullscreen-btn controls button" onclick="toggleFullscreen()">üñ•Ô∏è ÂÖ®ÁîªÈù¢</button>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        let time = 0;

        // Mandala parameters
        let symmetry = 8;
        let layers = 6;
        let rotationSpeed = 0.001;
        let colorSpeed = 0.5;
        let baseHue = Math.random() * 360;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resize);
        resize();

        // Mouse tracking
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        // Touch support
        document.addEventListener('touchmove', (e) => {
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        });

        // Click for new mandala
        document.addEventListener('click', () => {
            generateRandom();
        });

        function generateRandom() {
            symmetry = Math.floor(Math.random() * 8) + 4;
            layers = Math.floor(Math.random() * 8) + 4;
            rotationSpeed = (Math.random() - 0.5) * 0.004;
            colorSpeed = Math.random() * 1 + 0.2;
            baseHue = Math.random() * 360;
        }

        function drawMandala() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(canvas.width, canvas.height) * 0.45;

            // Dark background with trail effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Mouse influence
            const mouseInfluenceX = (mouseX / canvas.width - 0.5) * 2;
            const mouseInfluenceY = (mouseY / canvas.height - 0.5) * 2;

            time += 0.01;

            // Draw layers
            for (let layer = 0; layer < layers; layer++) {
                const layerProgress = layer / layers;
                const baseRadius = maxRadius * (0.2 + layerProgress * 0.8);

                for (let i = 0; i < symmetry; i++) {
                    const angle = (i / symmetry) * Math.PI * 2 + time * rotationSpeed * (layer + 1);

                    // Complex curves
                    const radiusVariation = Math.sin(time * 2 + layer + i * 0.5) * 20 * (1 + mouseInfluenceX);
                    const radius = baseRadius + radiusVariation;

                    // Dynamic hue
                    const hue = (baseHue + layer * 30 + i * 10 + time * colorSpeed * 50) % 360;
                    const saturation = 70 + Math.sin(time + layer) * 20;
                    const lightness = 50 + Math.sin(time * 2 + layer * 0.5) * 20;

                    ctx.beginPath();
                    ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.8)`;
                    ctx.lineWidth = 2 + Math.sin(time + layer) * 1;

                    // Draw petal-like shapes
                    const petalCount = 3 + Math.floor(layer * 0.5);
                    for (let p = 0; p < petalCount; p++) {
                        const petalAngle = angle + (p / petalCount) * Math.PI * 2;
                        const petalSize = radius * 0.3 * (1 + mouseInfluenceY * 0.5);

                        const x1 = centerX + Math.cos(petalAngle) * radius;
                        const y1 = centerY + Math.sin(petalAngle) * radius;

                        const cpAngle = petalAngle + Math.PI / 2;
                        const cpDist = petalSize * (1 + Math.sin(time * 3 + layer) * 0.3);
                        const cpx = centerX + Math.cos(cpAngle) * cpDist;
                        const cpy = centerY + Math.sin(cpAngle) * cpDist;

                        const x2 = centerX + Math.cos(petalAngle + 0.2) * (radius * 0.5);
                        const y2 = centerY + Math.sin(petalAngle + 0.2) * (radius * 0.5);

                        ctx.moveTo(x1, y1);
                        ctx.quadraticCurveTo(cpx, cpy, x2, y2);
                        ctx.stroke();
                    }

                    // Draw dots at intersections
                    const dotX = centerX + Math.cos(angle) * radius;
                    const dotY = centerY + Math.sin(angle) * radius;
                    ctx.beginPath();
                    ctx.arc(dotX, dotY, 3 + Math.sin(time * 2 + layer) * 2, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${hue + 180}, ${saturation}%, ${lightness + 20}%, 0.9)`;
                    ctx.fill();
                }
            }

            // Center glow
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 50);
            gradient.addColorStop(0, `hsla(${baseHue}, 80%, 60%, 0.3)`);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            requestAnimationFrame(drawMandala);
        }

        // Controls
        document.getElementById('randomBtn').addEventListener('click', generateRandom);

        document.getElementById('saveBtn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `mandala-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        });

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // Start animation
        drawMandala();
    </script>
</body>
</html>
