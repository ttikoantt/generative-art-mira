<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ•°å¼ã®åº­ | Mathematical Garden</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Arial', sans-serif;
            overflow-x: hidden;
            padding: 20px;
        }

        h1 {
            color: #ffffff;
            font-size: clamp(24px, 5vw, 36px);
            margin: 20px 0;
            text-align: center;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.7);
            font-size: clamp(12px, 3vw, 16px);
            margin-bottom: 20px;
            text-align: center;
        }

        #canvas-container {
            position: relative;
            width: 100%;
            max-width: 1200px;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        canvas {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info {
            color: rgba(255, 255, 255, 0.8);
            font-size: clamp(11px, 2.5vw, 14px);
            margin-top: 20px;
            text-align: center;
            max-width: 600px;
            line-height: 1.6;
        }

        .back-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
            z-index: 1000;
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            .back-button {
                top: 10px;
                right: 10px;
                padding: 8px 16px;
                font-size: 12px;
            }

            canvas {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <a href="../" class="back-button">â† æˆ»ã‚‹</a>
    <h1>ğŸŒ¸ æ•°å¼ã®åº­</h1>
    <p class="subtitle">æ•°å­¦çš„ãªæ•°å¼ã§ç¾ã—ã„æ¤ç‰©ã‚’ç”Ÿæˆ</p>

    <div id="canvas-container"></div>

    <p class="info">
        ã“ã‚Œã‚‰ã®èŠ±ã¯æ•°å­¦çš„ãªæ•°å¼ï¼ˆãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯æ–¹ç¨‹å¼ã¨ãƒ•ã‚§ãƒ«ãƒãƒ¼ã®èºæ—‹ï¼‰ã§æã‹ã‚Œã¦ã„ã¾ã™ã€‚
        è‡ªç„¶ç•Œã®ç¾ã—ã•ã¯ã€æ™‚ã«ã‚·ãƒ³ãƒ—ãƒ«ãªæ•°å­¦æ³•å‰‡ã§è¡¨ç¾ã§ãã¾ã™ã€‚
    </p>

    <script>
        // ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯èŠ±ã®æç”»
        function drawParametricFlower(ctx, x, y, size, config) {
            const { n, d, layers, color1, color2 } = config;

            for (let layer = 0; layer < layers; layer++) {
                const layerSize = size * (1 - layer * 0.15);
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, layerSize);
                
                gradient.addColorStop(0, color1);
                gradient.addColorStop(0.5, color2);
                gradient.addColorStop(1, 'transparent');

                ctx.beginPath();
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;

                for (let i = 0; i <= 360; i++) {
                    const k = i * d;
                    const r = layerSize * Math.cos(n * k * Math.PI / 180);
                    const px = x + r * Math.cos(k * Math.PI / 180);
                    const py = y + r * Math.sin(k * Math.PI / 180);

                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }

                ctx.closePath();
                ctx.stroke();
            }
        }

        // ãƒ•ã‚§ãƒ«ãƒãƒ¼ã®èºæ—‹ï¼ˆèŠ±å¼ï¼‰ã®æç”»
        function drawFermatRose(ctx, x, y, size, config) {
            const { n, petals, color1, color2, rotation } = config;

            const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);

            ctx.beginPath();
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 2.5;

            for (let i = 0; i <= 360 * n; i++) {
                const angle = (i + rotation) * Math.PI / 180;
                const r = size * Math.sin(petals * angle);
                const px = x + r * Math.cos(angle);
                const py = y + r * Math.sin(angle);

                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }

            ctx.stroke();
        }

        // è¤‡é›‘ãªãƒ‘ã‚¿ãƒ¼ãƒ³èŠ±
        function drawComplexFlower(ctx, x, y, size, config) {
            const { n1, n2, layers, color1, color2 } = config;

            for (let layer = 0; layer < layers; layer++) {
                const layerSize = size * (1 - layer * 0.12);
                const hueShift = layer * 20;

                const gradient = ctx.createRadialGradient(x, y, 0, x, y, layerSize);
                gradient.addColorStop(0, color1);
                gradient.addColorStop(0.3 + layer * 0.1, color2);
                gradient.addColorStop(1, 'transparent');

                ctx.beginPath();
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 1.5;

                for (let i = 0; i <= 360 * 2; i++) {
                    const angle = i * Math.PI / 180;
                    const r = layerSize * Math.sin(n1 * angle) * Math.cos(n2 * angle);
                    const px = x + r * Math.cos(angle);
                    const py = y + r * Math.sin(angle);

                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }

                ctx.stroke();
            }
        }

        // ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆç”Ÿæˆ
        function generateColorPalette() {
            const palettes = [
                ['#FF6B9D', '#C44569'],  // ãƒ”ãƒ³ã‚¯
                ['#4ECDC4', '#44A08D'],  // ã‚·ã‚¢ãƒ³
                ['#FFE66D', '#F7B731'],  // ã‚¤ã‚¨ãƒ­ãƒ¼
                ['#A29BFE', '#6C5CE7'],  // ãƒ‘ãƒ¼ãƒ—ãƒ«
                ['#FD79A8', '#E84393'],  // ãƒã‚¼ãƒ³ã‚¿
                ['#55EFC4', '#00B894'],  // ãƒŸãƒ³ãƒˆ
                ['#FDCB6E', '#E17055'],  // ã‚ªãƒ¬ãƒ³ã‚¸
                ['#74B9FF', '#0984E3'],  // ãƒ–ãƒ«ãƒ¼
            ];
            return palettes[Math.floor(Math.random() * palettes.length)];
        }

        // ãƒ¡ã‚¤ãƒ³æç”»é–¢æ•°
        function createFlowerGarden() {
            const container = document.getElementById('canvas-container');
            const canvasConfigs = [
                { width: 350, height: 350 },
                { width: 350, height: 350 },
                { width: 350, height: 350 },
                { width: 350, height: 350 },
                { width: 350, height: 350 },
                { width: 350, height: 350 }
            ];

            canvasConfigs.forEach((config, index) => {
                const canvas = document.createElement('canvas');
                canvas.width = config.width;
                canvas.height = config.height;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                const cx = config.width / 2;
                const cy = config.height / 2;
                const size = Math.min(config.width, config.height) * 0.4;

                const palette = generateColorPalette();

                // ãƒ©ãƒ³ãƒ€ãƒ ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                const flowerType = Math.random();

                if (flowerType < 0.33) {
                    // ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯èŠ±
                    const n = Math.floor(Math.random() * 5) + 2;
                    const d = Math.floor(Math.random() * 89) + 29;
                    const layers = Math.floor(Math.random() * 4) + 3;

                    drawParametricFlower(ctx, cx, cy, size, {
                        n, d, layers,
                        color1: palette[0],
                        color2: palette[1]
                    });
                } else if (flowerType < 0.66) {
                    // ãƒ•ã‚§ãƒ«ãƒãƒ¼ã®ãƒãƒ©
                    const n = Math.floor(Math.random() * 4) + 2;
                    const petals = Math.floor(Math.random() * 7) + 3;
                    const rotation = Math.random() * 360;

                    drawFermatRose(ctx, cx, cy, size, {
                        n, petals, rotation,
                        color1: palette[0],
                        color2: palette[1]
                    });
                } else {
                    // è¤‡é›‘ãªãƒ‘ã‚¿ãƒ¼ãƒ³
                    const n1 = Math.floor(Math.random() * 6) + 3;
                    const n2 = Math.floor(Math.random() * 4) + 2;
                    const layers = Math.floor(Math.random() * 5) + 4;

                    drawComplexFlower(ctx, cx, cy, size, {
                        n1, n2, layers,
                        color1: palette[0],
                        color2: palette[1]
                    });
                }
            });
        }

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«åº­ã‚’ç”Ÿæˆ
        createFlowerGarden();
    </script>
</body>
</html>
