<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Fractal Tree - Generative Art by Mira</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }

        .header {
            text-align: center;
            padding: 20px;
            color: #fff;
            z-index: 10;
        }

        .header h1 {
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00ff88, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: clamp(0.8rem, 2vw, 1rem);
            opacity: 0.7;
        }

        .canvas-container {
            position: relative;
            flex: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-end;
        }

        #canvas {
            display: block;
            cursor: pointer;
            touch-action: none;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .controls button {
            padding: 12px 24px;
            font-size: clamp(0.8rem, 2vw, 1rem);
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #00ff88, #00d4ff);
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
        }

        .controls button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }

        .controls button:active {
            transform: scale(0.95);
        }

        .info {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: clamp(0.7rem, 1.5vw, 0.9rem);
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        @media (max-width: 600px) {
            .info {
                top: auto;
                bottom: 100px;
                right: 10px;
                left: 10px;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üå≥ Fractal Tree</h1>
        <p>Click anywhere to grow a new tree</p>
    </div>

    <div class="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <div class="info">
        <div>Depth: <span id="depth">0</span></div>
        <div>Trees: <span id="treeCount">0</span></div>
    </div>

    <div class="controls">
        <button id="fullscreen">üì∫ Fullscreen</button>
        <button id="clear">üóëÔ∏è Clear</button>
        <button id="autoGrow">üå± Auto Grow</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let trees = [];
        let depthDisplay = document.getElementById('depth');
        let treeCountDisplay = document.getElementById('treeCount');
        let autoGrowing = false;
        let animationId = null;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            redraw();
        }

        window.addEventListener('resize', resize);
        resize();

        class Tree {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.length = 0;
                this.targetLength = 120 + Math.random() * 60;
                this.angle = -Math.PI / 2;
                this.branches = [];
                this.depth = 0;
                this.maxDepth = 10 + Math.floor(Math.random() * 3);
                this.growing = true;
                this.color = this.randomColor();
                this.growSpeed = 2 + Math.random() * 2;
                this.branchAngle = (20 + Math.random() * 20) * Math.PI / 180;
                this.lengthDecay = 0.7 + Math.random() * 0.1;
            }

            randomColor() {
                const colors = [
                    { start: '#00ff88', end: '#00d4ff' },
                    { start: '#ff6b6b', end: '#feca57' },
                    { start: '#a29bfe', end: '#fd79a8' },
                    { start: '#00d2d3', end: '#54a0ff' },
                    { start: '#ff9ff3', end: '#feca57' }
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            grow() {
                if (this.length < this.targetLength) {
                    this.length += this.growSpeed;
                    return true;
                } else if (this.branches.length === 0 && this.depth < this.maxDepth) {
                    // Create branches
                    const leftBranch = new Tree(this.x, this.y);
                    leftBranch.length = this.length * 0.5;
                    leftBranch.targetLength = this.length * this.lengthDecay;
                    leftBranch.angle = this.angle - this.branchAngle;
                    leftBranch.depth = this.depth + 1;
                    leftBranch.maxDepth = this.maxDepth;
                    leftBranch.color = this.color;
                    leftBranch.branchAngle = this.branchAngle;
                    leftBranch.lengthDecay = this.lengthDecay;
                    leftBranch.growSpeed = this.growSpeed * 0.9;
                    leftBranch.growing = true;

                    const rightBranch = new Tree(this.x, this.y);
                    rightBranch.length = this.length * 0.5;
                    rightBranch.targetLength = this.length * this.lengthDecay;
                    rightBranch.angle = this.angle + this.branchAngle;
                    rightBranch.depth = this.depth + 1;
                    rightBranch.maxDepth = this.maxDepth;
                    rightBranch.color = this.color;
                    rightBranch.branchAngle = this.branchAngle;
                    rightBranch.lengthDecay = this.lengthDecay;
                    rightBranch.growSpeed = this.growSpeed * 0.9;
                    rightBranch.growing = true;

                    this.branches = [leftBranch, rightBranch];
                    this.updateBranchPositions();
                }

                let stillGrowing = false;
                for (const branch of this.branches) {
                    if (branch.grow()) {
                        stillGrowing = true;
                    }
                }

                if (!stillGrowing && this.branches.length > 0) {
                    this.growing = false;
                }

                return stillGrowing || this.branches.some(b => b.growing);
            }

            updateBranchPositions() {
                if (this.branches.length > 0) {
                    const endX = this.x + Math.cos(this.angle) * this.length;
                    const endY = this.y + Math.sin(this.angle) * this.length;

                    this.branches[0].x = endX;
                    this.branches[0].y = endY;
                    this.branches[1].x = endX;
                    this.branches[1].y = endY;

                    for (const branch of this.branches) {
                        branch.updateBranchPositions();
                    }
                }
            }

            draw(ctx, parentX, parentY) {
                if (this.length <= 0) return;

                const endX = this.x + Math.cos(this.angle) * this.length;
                const endY = this.y + Math.sin(this.angle) * this.length;

                // Calculate color gradient based on depth
                const progress = this.depth / this.maxDepth;
                const color = this.interpolateColor(this.color.start, this.color.end, progress);

                ctx.beginPath();
                ctx.moveTo(parentX || this.x, parentY || this.y);
                ctx.lineTo(endX, endY);

                const lineWidth = Math.max(1, 10 - this.depth);
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.stroke();

                // Draw leaf at end of branch
                if (this.depth >= this.maxDepth - 2) {
                    this.drawLeaf(ctx, endX, endY, color);
                }

                for (const branch of this.branches) {
                    branch.draw(ctx, endX, endY);
                }
            }

            drawLeaf(ctx, x, y, color) {
                ctx.beginPath();
                ctx.arc(x, y, 3 + Math.random() * 2, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.6;
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            interpolateColor(color1, color2, factor) {
                const r1 = parseInt(color1.slice(1, 3), 16);
                const g1 = parseInt(color1.slice(3, 5), 16);
                const b1 = parseInt(color1.slice(5, 7), 16);

                const r2 = parseInt(color2.slice(1, 3), 16);
                const g2 = parseInt(color2.slice(3, 5), 16);
                const b2 = parseInt(color2.slice(5, 7), 16);

                const r = Math.round(r1 + (r2 - r1) * factor);
                const g = Math.round(g1 + (g2 - g1) * factor);
                const b = Math.round(b1 + (b2 - b1) * factor);

                return `rgb(${r}, ${g}, ${b})`;
            }

            getMaxDepth() {
                let maxD = this.depth;
                for (const branch of this.branches) {
                    maxD = Math.max(maxD, branch.getMaxDepth());
                }
                return maxD;
            }
        }

        function createTree(x, y) {
            const tree = new Tree(x, y);
            trees.push(tree);
            updateInfo();
        }

        function updateInfo() {
            if (trees.length > 0) {
                const maxDepth = Math.max(...trees.map(t => t.getMaxDepth()));
                depthDisplay.textContent = maxDepth;
            } else {
                depthDisplay.textContent = '0';
            }
            treeCountDisplay.textContent = trees.length;
        }

        function redraw() {
            ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (const tree of trees) {
                tree.draw(ctx);
            }
        }

        function animate() {
            let stillGrowing = false;
            for (const tree of trees) {
                if (tree.growing) {
                    if (tree.grow()) {
                        stillGrowing = true;
                    }
                    tree.updateBranchPositions();
                }
            }

            redraw();

            if (stillGrowing || autoGrowing) {
                animationId = requestAnimationFrame(animate);
            }
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            createTree(x, y);

            if (!animationId) {
                animate();
            }
        });

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            createTree(x, y);

            if (!animationId) {
                animate();
            }
        });

        document.getElementById('fullscreen').addEventListener('click', () => {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        });

        document.getElementById('clear').addEventListener('click', () => {
            trees = [];
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            updateInfo();
        });

        document.getElementById('autoGrow').addEventListener('click', () => {
            autoGrowing = !autoGrowing;
            if (autoGrowing) {
                autoGrowLoop();
            }
        });

        function autoGrowLoop() {
            if (!autoGrowing) return;

            const x = Math.random() * canvas.width;
            const y = canvas.height;
            createTree(x, y);

            if (!animationId) {
                animate();
            }

            setTimeout(autoGrowLoop, 500);
        }

        // Initial tree
        createTree(canvas.width / 2, canvas.height);
        animate();
    </script>
</body>
</html>
