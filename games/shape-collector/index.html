<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Shape Collector - Mira</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0a0f;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            touch-action: none;
        }
        
        canvas {
            display: block;
        }
        
        .ui {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            pointer-events: none;
        }
        
        .score {
            color: #00ffff;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .lives {
            color: #ff0066;
            font-size: 32px;
            text-shadow: 0 0 10px #ff0066;
        }
        
        .start-screen, .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .start-screen h1, .game-over-screen h1 {
            color: #ff00ff;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 30px #ff00ff;
            letter-spacing: 4px;
        }
        
        .start-screen p, .game-over-screen p {
            color: #00ffff;
            font-size: 18px;
            margin-bottom: 30px;
        }
        
        .btn {
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 15px 40px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
            pointer-events: auto;
        }
        
        .btn:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 30px #00ffff;
            transform: scale(1.05);
        }
        
        .hidden {
            display: none !important;
        }
        
        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            z-index: 100;
        }
        
        .fullscreen-btn:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 20px #00ffff;
        }
    </style>
</head>
<body>
    <div class="ui">
        <div class="score" id="score">SCORE: 0</div>
        <div class="lives" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
    </div>
    
    <canvas id="canvas"></canvas>
    
    <div class="start-screen" id="startScreen">
        <h1>SHAPE COLLECTOR</h1>
        <p>Click or tap to collect falling shapes!</p>
        <p>üî¥ Circle: +10 | üü¶ Square: +20 | üî∫ Triangle: +30</p>
        <p>‚ö†Ô∏è Avoid spikes! -1 life</p>
        <button class="btn" onclick="startGame()">START GAME</button>
    </div>
    
    <div class="game-over-screen hidden" id="gameOverScreen">
        <h1>GAME OVER</h1>
        <p id="finalScore">Score: 0</p>
        <button class="btn" onclick="restartGame()">PLAY AGAIN</button>
    </div>
    
    <button class="fullscreen-btn" onclick="toggleFullscreen()">‚õ∂ Fullscreen</button>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreEl = document.getElementById('finalScore');
        
        let width, height;
        let score = 0;
        let lives = 3;
        let gameRunning = false;
        let shapes = [];
        let particles = [];
        let lastSpawn = 0;
        let difficulty = 1;
        
        const shapeTypes = [
            { type: 'circle', points: 10, color: '#ff4444', size: 25, probability: 0.4 },
            { type: 'square', points: 20, color: '#4488ff', size: 30, probability: 0.3 },
            { type: 'triangle', points: 30, color: '#44ff88', size: 35, probability: 0.2 },
            { type: 'spike', points: -1, color: '#ff0066', size: 40, probability: 0.1 }
        ];
        
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        
        function createShape() {
            const rand = Math.random();
            let cumulative = 0;
            let shapeType = shapeTypes[0];
            
            for (const type of shapeTypes) {
                cumulative += type.probability;
                if (rand < cumulative) {
                    shapeType = type;
                    break;
                }
            }
            
            return {
                x: Math.random() * (width - 100) + 50,
                y: -50,
                ...shapeType,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.1,
                speed: (1 + Math.random() * 2) * difficulty
            };
        }
        
        function createParticles(x, y, color) {
            for (let i = 0; i < 15; i++) {
                const angle = (Math.PI * 2 / 15) * i;
                const speed = 2 + Math.random() * 3;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    color
                });
            }
        }
        
        function drawShape(shape) {
            ctx.save();
            ctx.translate(shape.x, shape.y);
            ctx.rotate(shape.rotation);
            ctx.fillStyle = shape.color;
            ctx.shadowBlur = 20;
            ctx.shadowColor = shape.color;
            
            if (shape.type === 'circle') {
                ctx.beginPath();
                ctx.arc(0, 0, shape.size, 0, Math.PI * 2);
                ctx.fill();
            } else if (shape.type === 'square') {
                ctx.fillRect(-shape.size/2, -shape.size/2, shape.size, shape.size);
            } else if (shape.type === 'triangle') {
                ctx.beginPath();
                ctx.moveTo(0, -shape.size/2);
                ctx.lineTo(-shape.size/2, shape.size/2);
                ctx.lineTo(shape.size/2, shape.size/2);
                ctx.closePath();
                ctx.fill();
            } else if (shape.type === 'spike') {
                ctx.fillStyle = shape.color;
                ctx.beginPath();
                ctx.moveTo(0, -shape.size/2);
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 / 8) * i;
                    const r = i % 2 === 0 ? shape.size/2 : shape.size/4;
                    ctx.lineTo(Math.cos(angle - Math.PI/2) * r, 
                              Math.sin(angle - Math.PI/2) * r);
                }
                ctx.closePath();
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function update(timestamp) {
            if (!gameRunning) return;
            
            // Spawn shapes
            if (timestamp - lastSpawn > 1000 / difficulty) {
                shapes.push(createShape());
                lastSpawn = timestamp;
            }
            
            // Update shapes
            shapes = shapes.filter(shape => {
                shape.y += shape.speed;
                shape.rotation += shape.rotationSpeed;
                
                // Check if off screen
                if (shape.y > height + 50) {
                    if (shape.type !== 'spike') {
                        // Missed a good shape
                        lives--;
                        updateLives();
                        if (lives <= 0) {
                            gameOver();
                        }
                    }
                    return false;
                }
                
                return true;
            });
            
            // Update particles
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                return p.life > 0;
            });
            
            // Increase difficulty
            difficulty = 1 + Math.floor(score / 100) * 0.1;
        }
        
        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 15, 0.3)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // Draw shapes
            shapes.forEach(shape => {
                drawShape(shape);
            });
            
            if (gameRunning) {
                requestAnimationFrame((t) => {
                    update(t);
                    draw();
                });
            }
        }
        
        function handleClick(x, y) {
            if (!gameRunning) return;
            
            for (let i = shapes.length - 1; i >= 0; i--) {
                const shape = shapes[i];
                const dx = x - shape.x;
                const dy = y - shape.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < shape.size) {
                    if (shape.type === 'spike') {
                        lives--;
                        updateLives();
                        createParticles(shape.x, shape.y, '#ff0066');
                        if (lives <= 0) {
                            gameOver();
                        }
                    } else {
                        score += shape.points;
                        updateScore();
                        createParticles(shape.x, shape.y, shape.color);
                    }
                    
                    shapes.splice(i, 1);
                    break;
                }
            }
        }
        
        function updateScore() {
            scoreEl.textContent = `SCORE: ${score}`;
        }
        
        function updateLives() {
            livesEl.textContent = '‚ù§Ô∏è'.repeat(lives);
        }
        
        function startGame() {
            score = 0;
            lives = 3;
            shapes = [];
            particles = [];
            difficulty = 1;
            gameRunning = true;
            updateScore();
            updateLives();
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            draw();
        }
        
        function gameOver() {
            gameRunning = false;
            finalScoreEl.textContent = `Final Score: ${score}`;
            gameOverScreen.classList.remove('hidden');
        }
        
        function restartGame() {
            startGame();
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        // Event listeners
        canvas.addEventListener('click', (e) => {
            handleClick(e.clientX, e.clientY);
        });
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleClick(touch.clientX, touch.clientY);
        });
        
        resize();
        window.addEventListener('resize', resize);
    </script>
</body>
</html>
