<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Asteroids Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            background: #000;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
            color: #00ffff;
            overflow: hidden;
        }

        .container {
            text-align: center;
            width: 100%;
            max-width: 800px;
            padding: 10px;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            }
            to {
                text-shadow: 0 0 30px rgba(0, 255, 255, 0.8), 0 0 40px rgba(0, 255, 255, 0.6);
            }
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .stat {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 8px;
            padding: 8px 15px;
            min-width: 100px;
        }

        .stat-label {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-bottom: 3px;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: bold;
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }

        canvas {
            border: 2px solid #00ffff;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        button {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 10px 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .fullscreen-btn {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.3rem;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            z-index: 1000;
        }

        .fullscreen-btn:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .mobile-controls {
            display: none;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        .mobile-btn {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 1.5rem;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mobile-btn:active {
            background: rgba(0, 255, 255, 0.4);
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .game-over h2 {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #ff0066;
        }

        .game-over p {
            font-size: 1.5rem;
            margin-bottom: 30px;
        }

        .game-over button {
            padding: 15px 30px;
            font-size: 1.2rem;
        }

        .instructions {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            .stat {
                min-width: 80px;
                padding: 6px 12px;
            }

            .stat-value {
                font-size: 1.1rem;
            }

            button {
                padding: 8px 15px;
                font-size: 0.8rem;
            }

            .mobile-controls {
                display: flex;
            }

            .instructions {
                display: none;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.3rem;
            }

            .mobile-btn {
                width: 70px;
                height: 70px;
                font-size: 1.3rem;
            }
        }
    </style>
</head>
<body>
    <button class="fullscreen-btn" onclick="toggleFullscreen()" title="ÂÖ®ÁîªÈù¢Ë°®Á§∫">‚õ∂</button>

    <div class="container">
        <h1>‚òÑÔ∏è Asteroids</h1>

        <div class="stats">
            <div class="stat">
                <div class="stat-label">Score</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Lives</div>
                <div class="stat-value" id="lives">3</div>
            </div>
            <div class="stat">
                <div class="stat-label">Level</div>
                <div class="stat-value" id="level">1</div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>

        <div class="controls">
            <button onclick="startGame()">‚ñ∂ Start</button>
            <button onclick="resetGame()">üîÑ Reset</button>
        </div>

        <div class="mobile-controls">
            <button class="mobile-btn" id="leftBtn">‚óÄ</button>
            <button class="mobile-btn" id="thrustBtn">‚ñ≤</button>
            <button class="mobile-btn" id="rightBtn">‚ñ∂</button>
            <button class="mobile-btn" id="fireBtn">‚óè</button>
        </div>

        <p class="instructions">Arrow keys to move | Space to shoot</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Initialize canvas
        function initCanvas() {
            const maxWidth = Math.min(window.innerWidth - 20, 700);
            const maxHeight = Math.min(window.innerHeight - 300, 500);

            canvas.width = maxWidth;
            canvas.height = maxHeight;
        }

        // Game state
        let ship = {
            x: 0,
            y: 0,
            angle: -Math.PI / 2,
            velocity: { x: 0, y: 0 },
            thrusting: false,
            rotatingLeft: false,
            rotatingRight: false
        };

        let asteroids = [];
        let bullets = [];
        let particles = [];
        let score = 0;
        let lives = 3;
        let level = 1;
        let gameRunning = false;
        let gameOver = false;
        let invincible = false;
        let invincibleTime = 0;

        const SHIP_SIZE = 20;
        const ROTATION_SPEED = 0.07;
        const THRUST_POWER = 0.1;
        const FRICTION = 0.99;
        const BULLET_SPEED = 10;
        const MAX_ASTEROIDS = 12;

        // Initialize game
        function initGame() {
            ship.x = canvas.width / 2;
            ship.y = canvas.height / 2;
            ship.angle = -Math.PI / 2;
            ship.velocity = { x: 0, y: 0 };
            asteroids = [];
            bullets = [];
            particles = [];
            score = 0;
            lives = 3;
            level = 1;
            gameOver = false;
            invincible = true;
            invincibleTime = 180;
            spawnAsteroids(4);
            updateUI();
        }

        // Spawn asteroids
        function spawnAsteroids(count) {
            for (let i = 0; i < count && asteroids.length < MAX_ASTEROIDS; i++) {
                let x, y;
                do {
                    x = Math.random() * canvas.width;
                    y = Math.random() * canvas.height;
                } while (distance(x, y, ship.x, ship.y) < 150);

                asteroids.push(createAsteroid(x, y, 3));
            }
        }

        // Create asteroid
        function createAsteroid(x, y, size) {
            const angle = Math.random() * Math.PI * 2;
            const speed = (Math.random() * 0.5 + 0.5) * (4 - size) * 0.5;
            const vertices = [];
            const numVertices = Math.floor(Math.random() * 5) + 7;

            for (let i = 0; i < numVertices; i++) {
                const angle = (i / numVertices) * Math.PI * 2;
                const variance = Math.random() * 0.4 + 0.8;
                vertices.push({
                    x: Math.cos(angle) * variance,
                    y: Math.sin(angle) * variance
                });
            }

            return {
                x: x,
                y: y,
                velocity: {
                    x: Math.cos(angle) * speed,
                    y: Math.sin(angle) * speed
                },
                radius: size * 15,
                size: size,
                angle: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02,
                vertices: vertices
            };
        }

        // Distance helper
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        // Update game
        function update() {
            if (!gameRunning || gameOver) return;

            // Update ship
            if (ship.rotatingLeft) ship.angle -= ROTATION_SPEED;
            if (ship.rotatingRight) ship.angle += ROTATION_SPEED;

            if (ship.thrusting) {
                ship.velocity.x += Math.cos(ship.angle) * THRUST_POWER;
                ship.velocity.y += Math.sin(ship.angle) * THRUST_POWER;

                // Thrust particles
                if (Math.random() > 0.5) {
                    const thrustAngle = ship.angle + Math.PI + (Math.random() - 0.5) * 0.5;
                    particles.push({
                        x: ship.x - Math.cos(ship.angle) * SHIP_SIZE,
                        y: ship.y - Math.sin(ship.angle) * SHIP_SIZE,
                        velocity: {
                            x: Math.cos(thrustAngle) * (Math.random() * 2 + 1),
                            y: Math.sin(thrustAngle) * (Math.random() * 2 + 1)
                        },
                        life: 20,
                        color: `hsl(${Math.random() * 60 + 10}, 100%, 50%)`
                    });
                }
            }

            ship.velocity.x *= FRICTION;
            ship.velocity.y *= FRICTION;
            ship.x += ship.velocity.x;
            ship.y += ship.velocity.y;

            // Wrap around
            ship.x = (ship.x + canvas.width) % canvas.width;
            ship.y = (ship.y + canvas.height) % canvas.height;

            // Update invincibility
            if (invincible) {
                invincibleTime--;
                if (invincibleTime <= 0) {
                    invincible = false;
                }
            }

            // Update asteroids
            asteroids.forEach(asteroid => {
                asteroid.x += asteroid.velocity.x;
                asteroid.y += asteroid.velocity.y;
                asteroid.angle += asteroid.rotationSpeed;

                // Wrap around
                asteroid.x = (asteroid.x + canvas.width) % canvas.width;
                asteroid.y = (asteroid.y + canvas.height) % canvas.height;
            });

            // Update bullets
            bullets = bullets.filter(bullet => {
                bullet.x += bullet.velocity.x;
                bullet.y += bullet.velocity.y;

                // Wrap around
                bullet.x = (bullet.x + canvas.width) % canvas.width;
                bullet.y = (bullet.y + canvas.height) % canvas.height;

                bullet.life--;
                return bullet.life > 0;
            });

            // Update particles
            particles = particles.filter(particle => {
                particle.x += particle.velocity.x;
                particle.y += particle.velocity.y;
                particle.life--;
                return particle.life > 0;
            });

            // Collision detection
            checkCollisions();

            // Check if all asteroids destroyed
            if (asteroids.length === 0) {
                level++;
                spawnAsteroids(4 + level);
                updateUI();
            }
        }

        // Check collisions
        function checkCollisions() {
            // Bullet-asteroid collisions
            bullets.forEach((bullet, bi) => {
                asteroids.forEach((asteroid, ai) => {
                    if (distance(bullet.x, bullet.y, asteroid.x, asteroid.y) < asteroid.radius) {
                        // Create explosion particles
                        for (let i = 0; i < 10; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = Math.random() * 3 + 1;
                            particles.push({
                                x: asteroid.x,
                                y: asteroid.y,
                                velocity: {
                                    x: Math.cos(angle) * speed,
                                    y: Math.sin(angle) * speed
                                },
                                life: 30,
                                color: `hsl(${Math.random() * 60 + 20}, 100%, 50%)`
                            });
                        }

                        // Split asteroid
                        if (asteroid.size > 1) {
                            for (let i = 0; i < 2; i++) {
                                asteroids.push(createAsteroid(
                                    asteroid.x + (Math.random() - 0.5) * 20,
                                    asteroid.y + (Math.random() - 0.5) * 20,
                                    asteroid.size - 1
                                ));
                            }
                        }

                        // Remove asteroid and bullet
                        asteroids.splice(ai, 1);
                        bullets.splice(bi, 1);

                        // Update score
                        score += (4 - asteroid.size) * 20;
                        updateUI();
                    }
                });
            });

            // Ship-asteroid collisions
            if (!invincible) {
                asteroids.forEach(asteroid => {
                    if (distance(ship.x, ship.y, asteroid.x, asteroid.y) < asteroid.radius + SHIP_SIZE / 2) {
                        // Create explosion
                        for (let i = 0; i < 20; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = Math.random() * 4 + 1;
                            particles.push({
                                x: ship.x,
                                y: ship.y,
                                velocity: {
                                    x: Math.cos(angle) * speed,
                                    y: Math.sin(angle) * speed
                                },
                                life: 40,
                                color: `hsl(${Math.random() * 60 + 180}, 100%, 50%)`
                            });
                        }

                        lives--;
                        updateUI();

                        if (lives <= 0) {
                            endGame();
                        } else {
                            // Reset ship
                            ship.x = canvas.width / 2;
                            ship.y = canvas.height / 2;
                            ship.velocity = { x: 0, y: 0 };
                            ship.angle = -Math.PI / 2;
                            invincible = true;
                            invincibleTime = 180;
                        }
                    }
                });
            }
        }

        // Draw game
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars (static background)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            for (let i = 0; i < 50; i++) {
                const x = (i * 73) % canvas.width;
                const y = (i * 137) % canvas.height;
                ctx.fillRect(x, y, 1, 1);
            }

            // Draw particles
            particles.forEach(particle => {
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.life / 40;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw asteroids
            asteroids.forEach(asteroid => {
                ctx.save();
                ctx.translate(asteroid.x, asteroid.y);
                ctx.rotate(asteroid.angle);

                ctx.strokeStyle = '#ff6600';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 10;

                ctx.beginPath();
                asteroid.vertices.forEach((vertex, i) => {
                    const x = vertex.x * asteroid.radius;
                    const y = vertex.y * asteroid.radius;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.closePath();
                ctx.stroke();

                ctx.shadowBlur = 0;
                ctx.restore();
            });

            // Draw bullets
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // Draw ship
            if (!invincible || Math.floor(Date.now() / 100) % 2 === 0) {
                ctx.save();
                ctx.translate(ship.x, ship.y);
                ctx.rotate(ship.angle);

                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;

                ctx.beginPath();
                ctx.moveTo(SHIP_SIZE, 0);
                ctx.lineTo(-SHIP_SIZE, -SHIP_SIZE / 2);
                ctx.lineTo(-SHIP_SIZE / 2, 0);
                ctx.lineTo(-SHIP_SIZE, SHIP_SIZE / 2);
                ctx.closePath();
                ctx.stroke();

                // Draw thrust
                if (ship.thrusting) {
                    ctx.strokeStyle = '#ff6600';
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(-SHIP_SIZE / 2, -SHIP_SIZE / 4);
                    ctx.lineTo(-SHIP_SIZE * 1.5, 0);
                    ctx.lineTo(-SHIP_SIZE / 2, SHIP_SIZE / 4);
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        // Fire bullet
        function fireBullet() {
            if (!gameRunning || gameOver) return;

            bullets.push({
                x: ship.x + Math.cos(ship.angle) * SHIP_SIZE,
                y: ship.y + Math.sin(ship.angle) * SHIP_SIZE,
                velocity: {
                    x: Math.cos(ship.angle) * BULLET_SPEED + ship.velocity.x,
                    y: Math.sin(ship.angle) * BULLET_SPEED + ship.velocity.y
                },
                life: 60
            });
        }

        // Update UI
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('level').textContent = level;
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        function startGame() {
            if (gameRunning) return;
            gameRunning = true;
            initGame();
        }

        // Reset game
        function resetGame() {
            gameRunning = false;
            gameOver = false;
            initGame();
            draw();
        }

        // End game
        function endGame() {
            gameOver = true;
            gameRunning = false;

            // Remove existing game over screen
            const existing = document.querySelector('.game-over');
            if (existing) existing.remove();

            // Create game over screen
            const gameOverDiv = document.createElement('div');
            gameOverDiv.className = 'game-over';
            gameOverDiv.innerHTML = `
                <h2>GAME OVER</h2>
                <p>Score: ${score}</p>
                <button onclick="resetGame(); this.parentElement.remove();">Play Again</button>
            `;
            document.body.appendChild(gameOverDiv);
        }

        // Fullscreen toggle
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') ship.rotatingLeft = true;
            if (e.key === 'ArrowRight') ship.rotatingRight = true;
            if (e.key === 'ArrowUp') ship.thrusting = true;
            if (e.key === ' ') {
                e.preventDefault();
                fireBullet();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') ship.rotatingLeft = false;
            if (e.key === 'ArrowRight') ship.rotatingRight = false;
            if (e.key === 'ArrowUp') ship.thrusting = false;
        });

        // Mobile controls
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const thrustBtn = document.getElementById('thrustBtn');
        const fireBtn = document.getElementById('fireBtn');

        leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); ship.rotatingLeft = true; });
        leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); ship.rotatingLeft = false; });
        rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); ship.rotatingRight = true; });
        rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); ship.rotatingRight = false; });
        thrustBtn.addEventListener('touchstart', (e) => { e.preventDefault(); ship.thrusting = true; });
        thrustBtn.addEventListener('touchend', (e) => { e.preventDefault(); ship.thrusting = false; });
        fireBtn.addEventListener('touchstart', (e) => { e.preventDefault(); fireBullet(); });

        // Handle resize
        window.addEventListener('resize', () => {
            initCanvas();
            draw();
        });

        // Initialize
        initCanvas();
        initGame();
        draw();
        gameLoop();
    </script>
</body>
</html>
