<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Stack Tower - 積み木タワー</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            touch-action: manipulation;
        }
        #gameCanvas {
            display: block;
            cursor: pointer;
        }
        .ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            pointer-events: none;
        }
        .score {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 12px 24px;
            border-radius: 25px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        .best-score {
            background: rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 12px 24px;
            border-radius: 25px;
            color: white;
            font-size: 18px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        .fullscreen-btn {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
            z-index: 100;
            pointer-events: auto;
        }
        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        .fullscreen-btn:active {
            transform: scale(0.95);
        }
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 100;
        }
        .game-over h2 {
            font-size: 32px;
            color: #667eea;
            margin-bottom: 20px;
        }
        .game-over p {
            font-size: 18px;
            color: #333;
            margin-bottom: 10px;
        }
        .game-over button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.2s;
        }
        .game-over button:hover {
            transform: scale(1.05);
        }
        .game-over button:active {
            transform: scale(0.95);
        }
        .combo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            pointer-events: none;
            opacity: 0;
            transition: all 0.3s;
            z-index: 50;
        }
        .combo.show {
            opacity: 1;
            animation: comboAnim 0.5s ease-out;
        }
        @keyframes comboAnim {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }
        @media (max-width: 768px) {
            .score {
                font-size: 20px;
                padding: 10px 20px;
            }
            .best-score {
                font-size: 16px;
                padding: 10px 20px;
            }
            .game-over {
                padding: 30px 20px;
                width: 90%;
            }
            .game-over h2 {
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui">
        <div class="score">スコア: <span id="score">0</span></div>
        <div class="best-score">ベスト: <span id="bestScore">0</span></div>
    </div>
    
    <button class="fullscreen-btn" onclick="toggleFullscreen()">全画面</button>
    
    <div class="combo" id="combo"></div>
    
    <div class="game-over" id="gameOver">
        <h2>ゲームオーバー</h2>
        <p>スコア: <span id="finalScore">0</span></p>
        <p>ベストスコア: <span id="finalBest">0</span></p>
        <button onclick="restartGame()">もう一度</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        // ゲーム設定
        const BLOCK_HEIGHT = 40;
        const INITIAL_BLOCK_WIDTH = 200;
        const INITIAL_BLOCK_X = (width - INITIAL_BLOCK_WIDTH) / 2;
        const BASE_Y = height - 100;
        const BLOCK_SPEED = 4;

        // ゲーム状態
        let blocks = [];
        let currentBlock = null;
        let score = 0;
        let bestScore = parseInt(localStorage.getItem('stackTowerBest')) || 0;
        let combo = 0;
        let gameOver = false;
        let cameraY = 0;
        let targetCameraY = 0;
        let direction = 1;

        // 色パレット（グラデーション）
        const colors = [
            { h: 0, s: 70, l: 60 },
            { h: 30, s: 70, l: 60 },
            { h: 60, s: 70, l: 60 },
            { h: 90, s: 70, l: 60 },
            { h: 120, s: 70, l: 60 },
            { h: 150, s: 70, l: 60 },
            { h: 180, s: 70, l: 60 },
            { h: 210, s: 70, l: 60 },
            { h: 240, s: 70, l: 60 },
            { h: 270, s: 70, l: 60 },
            { h: 300, s: 70, l: 60 },
            { h: 330, s: 70, l: 60 }
        ];

        function initGame() {
            blocks = [];
            score = 0;
            combo = 0;
            gameOver = false;
            cameraY = 0;
            targetCameraY = 0;
            direction = 1;

            // ベースブロック
            blocks.push({
                x: (width - INITIAL_BLOCK_WIDTH) / 2,
                y: BASE_Y,
                width: INITIAL_BLOCK_WIDTH,
                height: BLOCK_HEIGHT,
                color: colors[0],
                fallen: null
            });

            // 次のブロック
            spawnNextBlock();

            updateUI();
            document.getElementById('gameOver').style.display = 'none';
        }

        function spawnNextBlock() {
            const prevBlock = blocks[blocks.length - 1];
            const colorIndex = blocks.length % colors.length;
            
            currentBlock = {
                x: 0,
                y: prevBlock.y - BLOCK_HEIGHT,
                width: prevBlock.width,
                height: BLOCK_HEIGHT,
                color: colors[colorIndex],
                fallen: null
            };

            // ランダムな開始位置と方向
            direction = Math.random() > 0.5 ? 1 : -1;
            currentBlock.x = direction === 1 ? -currentBlock.width : width;
        }

        function placeBlock() {
            if (gameOver || !currentBlock) return;

            const prevBlock = blocks[blocks.length - 1];
            const overlap = calculateOverlap(currentBlock, prevBlock);

            if (overlap <= 0) {
                // 完全に外れた
                endGame();
                return;
            }

            // オーバーラップ部分を計算
            let newWidth = overlap;
            let newX = currentBlock.x;
            let fallenX = currentBlock.x;
            let fallenWidth = currentBlock.width - overlap;

            // オーバーラップ位置を調整
            if (currentBlock.x < prevBlock.x) {
                newX = prevBlock.x;
                fallenX = currentBlock.x;
            } else if (currentBlock.x + currentBlock.width > prevBlock.x + prevBlock.width) {
                newX = prevBlock.x + prevBlock.width - overlap;
                fallenX = prevBlock.x + prevBlock.width;
            }

            // 完璧な配置
            if (Math.abs(currentBlock.x - prevBlock.x) < 3) {
                newWidth = prevBlock.width;
                newX = prevBlock.x;
                combo++;
                fallenWidth = 0;
                
                // コンボ表示
                if (combo >= 2) {
                    showCombo(combo);
                }
            } else {
                combo = 0;
            }

            // 新しいブロック
            blocks.push({
                x: newX,
                y: currentBlock.y,
                width: newWidth,
                height: BLOCK_HEIGHT,
                color: currentBlock.color,
                fallen: fallenWidth > 0 ? {
                    x: fallenX,
                    width: fallenWidth,
                    vy: 0,
                    rotation: 0,
                    vr: (Math.random() - 0.5) * 0.2
                } : null
            });

            score++;
            updateUI();

            // カメラを移動
            if (blocks.length > 5) {
                targetCameraY = (blocks.length - 5) * BLOCK_HEIGHT;
            }

            // 次のブロック
            spawnNextBlock();
        }

        function calculateOverlap(block1, block2) {
            const left = Math.max(block1.x, block2.x);
            const right = Math.min(block1.x + block1.width, block2.x + block2.width);
            return Math.max(0, right - left);
        }

        function update() {
            if (gameOver) return;

            // カメラをスムーズに移動
            cameraY += (targetCameraY - cameraY) * 0.1;

            // 現在のブロックを移動
            if (currentBlock) {
                currentBlock.x += BLOCK_SPEED * direction;

                // 壁で反転
                if (currentBlock.x + currentBlock.width > width) {
                    direction = -1;
                } else if (currentBlock.x < 0) {
                    direction = 1;
                }
            }

            // 落下するブロックを更新
            blocks.forEach(block => {
                if (block.fallen) {
                    block.fallen.vy += 0.5;
                    block.fallen.y += block.fallen.vy;
                    block.fallen.rotation += block.fallen.vr;
                }
            });
        }

        function draw() {
            // 背景をクリア
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#667eea');
            gradient.addColorStop(1, '#764ba2');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            ctx.translate(0, cameraY);

            // ブロックを描画
            blocks.forEach(block => {
                // メインブロック
                const blockGradient = ctx.createLinearGradient(block.x, block.y, block.x, block.y + block.height);
                blockGradient.addColorStop(0, `hsl(${block.color.h}, ${block.color.s}%, ${block.color.l + 20}%)`);
                blockGradient.addColorStop(1, `hsl(${block.color.h}, ${block.color.s}%, ${block.color.l}%)`);

                ctx.fillStyle = blockGradient;
                ctx.fillRect(block.x, block.y, block.width, block.height);

                // ブロックの影
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(block.x, block.y + block.height - 5, block.width, 5);

                // ブロックのハイライト
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(block.x, block.y, block.width, 3);

                // 落下するブロック
                if (block.fallen && block.fallen.y < height + 100) {
                    ctx.save();
                    ctx.translate(block.fallen.x + block.fallen.width / 2, block.fallen.y);
                    ctx.rotate(block.fallen.rotation);
                    
                    const fallenGradient = ctx.createLinearGradient(-block.fallen.width / 2, 0, -block.fallen.width / 2, BLOCK_HEIGHT);
                    fallenGradient.addColorStop(0, `hsl(${block.color.h}, ${block.color.s}%, ${block.color.l + 20}%)`);
                    fallenGradient.addColorStop(1, `hsl(${block.color.h}, ${block.color.s}%, ${block.color.l}%)`);
                    
                    ctx.fillStyle = fallenGradient;
                    ctx.fillRect(-block.fallen.width / 2, 0, block.fallen.width, BLOCK_HEIGHT);
                    
                    ctx.restore();
                }
            });

            // 現在のブロックを描画
            if (currentBlock && !gameOver) {
                const blockGradient = ctx.createLinearGradient(currentBlock.x, currentBlock.y, currentBlock.x, currentBlock.y + currentBlock.height);
                blockGradient.addColorStop(0, `hsl(${currentBlock.color.h}, ${currentBlock.color.s}%, ${currentBlock.color.l + 20}%)`);
                blockGradient.addColorStop(1, `hsl(${currentBlock.color.h}, ${currentBlock.color.s}%, ${currentBlock.color.l}%)`);

                ctx.fillStyle = blockGradient;
                ctx.fillRect(currentBlock.x, currentBlock.y, currentBlock.width, currentBlock.height);

                // ブロックの影
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(currentBlock.x, currentBlock.y + currentBlock.height - 5, currentBlock.width, 5);

                // ブロックのハイライト
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(currentBlock.x, currentBlock.y, currentBlock.width, 3);
            }

            ctx.restore();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameOver = true;

            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('stackTowerBest', bestScore);
            }

            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalBest').textContent = bestScore;
            document.getElementById('gameOver').style.display = 'block';
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('bestScore').textContent = bestScore;
        }

        function showCombo(count) {
            const comboEl = document.getElementById('combo');
            const messages = ['', '', 'Nice!', 'Great!', 'Awesome!', 'Amazing!', 'Incredible!', 'LEGENDARY!'];
            comboEl.textContent = messages[Math.min(count, messages.length - 1)] || 'PERFECT!';
            comboEl.classList.add('show');
            setTimeout(() => comboEl.classList.remove('show'), 500);
        }

        function restartGame() {
            initGame();
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // イベントリスナー
        canvas.addEventListener('click', placeBlock);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            placeBlock();
        });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            initGame();
        });

        // キーボード操作
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                placeBlock();
            }
        });

        // 初期化
        document.getElementById('bestScore').textContent = bestScore;
        initGame();
        gameLoop();
    </script>
</body>
</html>
