<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚¸ã‚§ãƒãƒ¬ãƒ¼ãƒ†ã‚£ãƒ–ãƒ»ã‚«ãƒ«ãƒ‡ãƒ©</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
        }

        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        canvas {
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            align-items: center;
        }

        button {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            color: #1a1a1a;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
        }

        button:active {
            transform: scale(0.95);
        }

        .info {
            color: #888;
            font-size: 12px;
            text-align: center;
        }

        .fullscreen-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        @media (max-width: 600px) {
            canvas {
                max-width: 95vw;
                max-height: 70vh;
            }

            .controls {
                flex-direction: column;
            }

            button {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div class="controls">
            <button id="generateBtn">ğŸŒ‹ æ–°ã—ã„ã‚«ãƒ«ãƒ‡ãƒ©ã‚’ç”Ÿæˆ</button>
            <button id="fullscreenBtn" class="fullscreen-btn">ğŸ“º å…¨ç”»é¢è¡¨ç¤º</button>
        </div>
        <p class="info">ã‚·ãƒ³ãƒ—ãƒ«ãªæ•°å¼ãŒç”Ÿã¿å‡ºã™è¤‡é›‘ãªåœ°å½¢</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Canvas size
        const size = Math.min(window.innerWidth * 0.8, 600);
        canvas.width = size;
        canvas.height = size;

        // Caldera parameters
        let centerX, centerY;
        let rings = [];
        let colorPalette = [];

        function generateCaldera() {
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;

            // Generate random color palette
            colorPalette = generatePalette();

            // Generate rings (from outer to inner)
            rings = [];
            const numRings = 8 + Math.floor(Math.random() * 8);

            for (let i = 0; i < numRings; i++) {
                const progress = i / numRings; // 0 = outer, 1 = inner

                rings.push({
                    radius: (canvas.width * 0.45) * (1 - progress * 0.9), // Gets smaller toward center
                    noise: 10 + Math.random() * 30,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.02,
                    segments: 30 + Math.floor(Math.random() * 30),
                    color: getColor(progress),
                    speed: 0.001 + Math.random() * 0.002
                });
            }
        }

        function generatePalette() {
            const palettes = [
                // Magma palette
                [
                    { r: 76, g: 20, b: 20 },    // Dark red-brown
                    { r: 139, g: 45, b: 45 },   // Rust
                    { r: 207, g: 85, b: 85 },   // Muted red
                    { r: 255, g: 140, b: 80 },  // Orange
                    { r: 255, g: 220, b: 120 }  // Yellow
                ],
                // Ocean palette
                [
                    { r: 10, g: 40, b: 60 },    // Deep blue
                    { r: 20, g: 70, b: 100 },   // Medium blue
                    { r: 40, g: 110, b: 150 },  // Light blue
                    { r: 80, g: 160, b: 200 },  // Sky blue
                    { r: 150, g: 210, b: 240 }  // Pale blue
                ],
                // Forest palette
                [
                    { r: 20, g: 40, b: 20 },    // Dark green
                    { r: 40, g: 70, b: 35 },    // Forest green
                    { r: 70, g: 110, b: 60 },   // Medium green
                    { r: 120, g: 160, b: 100 }, // Light green
                    { r: 180, g: 220, b: 160 }  // Pale green
                ],
                // Sunset palette
                [
                    { r: 40, g: 20, b: 60 },    // Purple
                    { r: 100, g: 40, b: 80 },   // Magenta
                    { r: 180, g: 70, b: 80 },   // Pink-red
                    { r: 255, g: 120, b: 80 },  // Orange
                    { r: 255, g: 200, b: 120 }  // Yellow
                ]
            ];

            return palettes[Math.floor(Math.random() * palettes.length)];
        }

        function getColor(progress) {
            // Progress: 0 = outer, 1 = inner
            const paletteIndex = Math.floor(progress * (colorPalette.length - 1));
            const nextIndex = Math.min(paletteIndex + 1, colorPalette.length - 1);
            const localProgress = (progress * (colorPalette.length - 1)) - paletteIndex;

            const c1 = colorPalette[paletteIndex];
            const c2 = colorPalette[nextIndex];

            return {
                r: Math.round(c1.r + (c2.r - c1.r) * localProgress),
                g: Math.round(c1.g + (c2.g - c1.g) * localProgress),
                b: Math.round(c1.b + (c2.b - c1.b) * localProgress)
            };
        }

        function draw() {
            // Clear with dark background
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw rings from outer to inner
            rings.forEach((ring, index) => {
                ctx.beginPath();

                // Create jagged circle
                for (let i = 0; i <= ring.segments; i++) {
                    const angle = (i / ring.segments) * Math.PI * 2 + ring.rotation;

                    // Add noise to radius
                    const noiseOffset = Math.sin(angle * 3) * ring.noise +
                                       Math.cos(angle * 7) * ring.noise * 0.5 +
                                       Math.sin(angle * 13) * ring.noise * 0.3;

                    const r = ring.radius + noiseOffset;
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.closePath();

                // Fill with color
                const alpha = 0.4 + (index / rings.length) * 0.4;
                ctx.fillStyle = `rgba(${ring.color.r}, ${ring.color.g}, ${ring.color.b}, ${alpha})`;
                ctx.fill();

                // Stroke
                ctx.strokeStyle = `rgba(${ring.color.r}, ${ring.color.g}, ${ring.color.b}, 0.8)`;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Slowly rotate
                ring.rotation += ring.speed;
            });

            // Draw center glow
            const gradient = ctx.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, 50
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(centerX - 50, centerY - 50, 100, 100);

            requestAnimationFrame(draw);
        }

        function animate() {
            generateCaldera();
            draw();
        }

        // Event listeners
        document.getElementById('generateBtn').addEventListener('click', animate);
        document.getElementById('fullscreenBtn').addEventListener('click', () => {
            if (canvas.requestFullscreen) {
                canvas.requestFullscreen();
            } else if (canvas.webkitRequestFullscreen) {
                canvas.webkitRequestFullscreen();
            }
        });

        // Initial draw
        animate();
    </script>
</body>
</html>
