<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Field Landscape</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', system-ui, sans-serif;
            padding: 20px;
        }

        .container {
            text-align: center;
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 1.8rem;
        }

        .subtitle {
            color: #888;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        canvas {
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 255, 255, 0.2);
            max-width: 100%;
            cursor: pointer;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .info {
            color: #666;
            margin-top: 15px;
            font-size: 0.85rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒŠ Flow Field Landscape</h1>
        <p class="subtitle">æµã‚Œå ´ãŒç¹”ã‚Šãªã™é¢¨æ™¯çš„ãƒ‘ã‚¿ãƒ¼ãƒ³</p>

        <canvas id="canvas"></canvas>

        <div class="controls">
            <button onclick="regenerate()">ğŸ² æ–°ã—ã„é¢¨æ™¯</button>
            <button onclick="toggleAnimation()">â¯ï¸ ä¸€æ™‚åœæ­¢/å†ç”Ÿ</button>
            <button onclick="download()">ğŸ’¾ ä¿å­˜</button>
        </div>

        <p class="info">ã‚¯ãƒªãƒƒã‚¯ã§å¹²æ¸‰ | è‡ªç„¶ãªæµã‚Œã‚’æ¨¡ã—ãŸé¢¨æ™¯çš„ãƒ•ãƒ­ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // è¨­å®š
        let width, height;
        let particles = [];
        let flowField = [];
        let animationId;
        let isAnimating = true;
        let scale = 15;
        let rows, cols;
        let zOff = 0;
        let hueOffset = 0;

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
        class Particle {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.vx = 0;
                this.vy = 0;
                this.history = [];
                this.maxHistory = 15;
                this.speed = Math.random() * 2 + 1;
                this.hue = Math.random() * 60 + hueOffset;
            }

            update() {
                // ãƒ•ãƒ­ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰è§’åº¦ã‚’å–å¾—
                let x = Math.floor(this.x / scale);
                let y = Math.floor(this.y / scale);
                let index = x + y * cols;

                if (flowField[index]) {
                    let angle = flowField[index];
                    this.vx = Math.cos(angle) * this.speed;
                    this.vy = Math.sin(angle) * this.speed;
                }

                // å±¥æ­´ã‚’è¨˜éŒ²
                this.history.push({ x: this.x, y: this.y });
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }

                // ç§»å‹•
                this.x += this.vx;
                this.y += this.vy;

                // è‰²ã‚’å°‘ã—ãšã¤å¤‰åŒ–
                this.hue += 0.1;

                // ç”»é¢å¤–ã«å‡ºãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
                if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                    this.reset();
                }
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.history = [];
                this.hue = Math.random() * 60 + hueOffset;
            }

            draw() {
                if (this.history.length < 2) return;

                ctx.beginPath();
                ctx.moveTo(this.history[0].x, this.history[0].y);

                for (let i = 1; i < this.history.length; i++) {
                    ctx.lineTo(this.history[i].x, this.history[i].y);
                }

                let alpha = (this.history.length / this.maxHistory) * 0.6;
                ctx.strokeStyle = `hsla(${this.hue}, 80%, 60%, ${alpha})`;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }

        // åˆæœŸåŒ–
        function init() {
            width = Math.min(800, window.innerWidth - 40);
            height = Math.min(600, window.innerHeight - 200);

            canvas.width = width;
            canvas.height = height;

            cols = Math.floor(width / scale) + 1;
            rows = Math.floor(height / scale) + 1;

            flowField = new Array(cols * rows);
            particles = [];

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ä½œæˆ
            for (let i = 0; i < 800; i++) {
                particles.push(new Particle());
            }
        }

        // Perliné¢¨ãƒã‚¤ã‚ºï¼ˆç°¡æ˜“ç‰ˆï¼‰
        function noise(x, y, z) {
            let p = Math.sin(x * 12.9898 + y * 78.233 + z * 37.719) * 43758.5453;
            return p - Math.floor(p);
        }

        // ãƒ•ãƒ­ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ›´æ–°
        function updateFlowField() {
            let yOff = 0;
            for (let y = 0; y < rows; y++) {
                let xOff = 0;
                for (let x = 0; x < cols; x++) {
                    let index = x + y * cols;

                    // è¤‡æ•°ã®ãƒã‚¤ã‚ºãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’é‡ã­ã¦è‡ªç„¶ãªæµã‚Œã«
                    let n1 = noise(xOff * 0.1, yOff * 0.1, zOff) * Math.PI * 4;
                    let n2 = noise(xOff * 0.05 + 100, yOff * 0.05 + 100, zOff * 0.5) * Math.PI * 2;
                    let angle = n1 + n2;

                    flowField[index] = angle;
                    xOff += 0.1;
                }
                yOff += 0.1;
            }
            zOff += 0.003;
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        function animate() {
            if (!isAnimating) return;

            // è–„ã„ãƒˆãƒ¬ã‚¤ãƒ«åŠ¹æœ
            ctx.fillStyle = 'rgba(10, 10, 15, 0.03)';
            ctx.fillRect(0, 0, width, height);

            updateFlowField();
            hueOffset += 0.05;

            particles.forEach(p => {
                p.update();
                p.draw();
            });

            animationId = requestAnimationFrame(animate);
        }

        // å†ç”Ÿæˆ
        function regenerate() {
            cancelAnimationFrame(animationId);

            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, width, height);

            zOff = Math.random() * 1000;
            hueOffset = Math.random() * 360;

            particles.forEach(p => p.reset());

            isAnimating = true;
            animate();
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒˆã‚°ãƒ«
        function toggleAnimation() {
            isAnimating = !isAnimating;
            if (isAnimating) {
                animate();
            }
        }

        // ä¿å­˜
        function download() {
            const link = document.createElement('a');
            link.download = 'flow-field-landscape.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        // ã‚¯ãƒªãƒƒã‚¯ã§å¹²æ¸‰
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // ã‚¯ãƒªãƒƒã‚¯ä½ç½®è¿‘ãã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’èª˜å°
            particles.forEach(p => {
                let dx = x - p.x;
                let dy = y - p.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 150) {
                    p.vx += dx * 0.05;
                    p.vy += dy * 0.05;
                    p.hue = Math.random() * 60 + 180; // é’ç³»ã«å¤‰åŒ–
                }
            });
        });

        // é–‹å§‹
        init();
        animate();
    </script>
</body>
</html>
