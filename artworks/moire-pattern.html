<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moire Pattern Art - „É¢„Ç¢„É¨Á∏û„Ç¢„Éº„Éà</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: #0ff;
            font-size: 12px;
            z-index: 100;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid #0ff;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #0ff;
        }

        .control-group input[type="range"] {
            width: 150px;
            accent-color: #0ff;
        }

        .control-group input[type="color"] {
            width: 50px;
            height: 30px;
            border: none;
            cursor: pointer;
        }

        .btn {
            background: linear-gradient(135deg, #0ff, #00f);
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #0ff;
        }

        .info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: #0ff;
            font-size: 12px;
            border: 1px solid #0ff;
        }

        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        @media (max-width: 768px) {
            .controls {
                font-size: 10px;
                padding: 10px;
                max-height: 40vh;
            }

            .control-group input[type="range"] {
                width: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="canvas-container">
        <canvas id="moireCanvas"></canvas>
    </div>

    <div class="controls">
        <h3 style="margin-bottom: 15px; color: #0ff;">üé® „É¢„Ç¢„É¨Á∏û„Ç≥„É≥„Éà„É≠„Éº„É´</h3>

        <div class="control-group">
            <label>ÂÜÜ„ÅÆÊï∞: <span id="circleCountValue">15</span></label>
            <input type="range" id="circleCount" min="3" max="30" value="15">
        </div>

        <div class="control-group">
            <label>ÂÜÜ„ÅÆÈñìÈöî: <span id="spacingValue">20</span></label>
            <input type="range" id="spacing" min="5" max="50" value="20">
        </div>

        <div class="control-group">
            <label>Á∑ö„ÅÆÂ§™„Åï: <span id="lineWidthValue">1</span></label>
            <input type="range" id="lineWidth" min="0.5" max="5" value="1" step="0.5">
        </div>

        <div class="control-group">
            <label>ÂõûËª¢ÈÄüÂ∫¶: <span id="rotationSpeedValue">0.5</span></label>
            <input type="range" id="rotationSpeed" min="0" max="2" value="0.5" step="0.1">
        </div>

        <div class="control-group">
            <label>„Éë„Çø„Éº„É≥„Çø„Ç§„Éó:</label>
            <select id="patternType" style="width: 150px; padding: 5px; background: #000; color: #0ff; border: 1px solid #0ff;">
                <option value="concentric">ÂêåÂøÉÂÜÜ</option>
                <option value="radial">ÊîæÂ∞ÑÁ∑ö</option>
                <option value="spiral">Ëû∫Êóã</option>
                <option value="lissajous">„É™„Çµ„Éº„Ç∏„É•</option>
            </select>
        </div>

        <div class="control-group">
            <label>„É°„Ç§„É≥„Ç´„É©„Éº:</label>
            <input type="color" id="mainColor" value="#00ffff">
        </div>

        <div class="control-group">
            <label>„Çª„Ç´„É≥„Éâ„Ç´„É©„Éº:</label>
            <input type="color" id="secondColor" value="#ff00ff">
        </div>

        <div class="control-group">
            <label>
                <input type="checkbox" id="rainbowMode"> „É¨„Ç§„É≥„Éú„Éº„É¢„Éº„Éâ
            </label>
        </div>

        <div class="control-group">
            <label>
                <input type="checkbox" id="glowEffect" checked> „Ç∞„É≠„ÉºÂäπÊûú
            </label>
        </div>

        <button class="btn" id="randomize">üé≤ „É©„É≥„ÉÄ„É†</button>
        <button class="btn" id="saveImage">üì∏ ‰øùÂ≠ò</button>
    </div>

    <button class="btn fullscreen-btn" id="fullscreenBtn">üñ•Ô∏è ÂÖ®ÁîªÈù¢</button>

    <div class="info">
        <div>„Éû„Ç¶„Çπ/„Çø„ÉÉ„ÉÅ„Åß‰∏≠ÂøÉ‰ΩçÁΩÆ„ÇíÂ§âÊõ¥</div>
        <div id="fps">FPS: 60</div>
    </div>

    <script>
        const canvas = document.getElementById('moireCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let centerX, centerY;
        let time = 0;
        let mouseX, mouseY;
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;

        // „Éë„É©„É°„Éº„Çø
        let params = {
            circleCount: 15,
            spacing: 20,
            lineWidth: 1,
            rotationSpeed: 0.5,
            patternType: 'concentric',
            mainColor: '#00ffff',
            secondColor: '#ff00ff',
            rainbowMode: false,
            glowEffect: true
        };

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            centerX = width / 2;
            centerY = height / 2;
            mouseX = centerX;
            mouseY = centerY;
        }

        function drawConcentric() {
            for (let i = 0; i < params.circleCount; i++) {
                ctx.save();
                ctx.translate(mouseX, mouseY);
                ctx.rotate(time * params.rotationSpeed * (i % 2 === 0 ? 1 : -1));

                const baseRadius = i * params.spacing;
                const color = getColor(i);

                if (params.glowEffect) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = color;
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = params.lineWidth;

                // ÂÜÜ„ÇíÊèèÁîª
                ctx.beginPath();
                ctx.arc(0, 0, baseRadius + Math.sin(time * 2 + i) * 5, 0, Math.PI * 2);
                ctx.stroke();

                // „ÇÇ„ÅÜ‰∏ÄÁµÑ„ÅÆÂÜÜÔºàÂ∞ë„ÅóËßíÂ∫¶„Çí„Åö„Çâ„Åó„Å¶„É¢„Ç¢„É¨ÂäπÊûú„ÇíÂº∑ÂåñÔºâ
                ctx.rotate(Math.PI / params.circleCount);
                ctx.beginPath();
                ctx.arc(0, 0, baseRadius + Math.cos(time * 2 + i) * 5, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }
        }

        function drawRadial() {
            for (let layer = 0; layer < params.circleCount; layer++) {
                ctx.save();
                ctx.translate(mouseX, mouseY);
                ctx.rotate(time * params.rotationSpeed * (layer % 2 === 0 ? 1 : -1));

                const radius = (layer + 1) * params.spacing * 2;
                const lines = 12 + layer * 2;
                const color = getColor(layer);

                if (params.glowEffect) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = color;
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = params.lineWidth;

                for (let i = 0; i < lines; i++) {
                    const angle = (Math.PI * 2 / lines) * i;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius
                    );
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        function drawSpiral() {
            for (let layer = 0; layer < params.circleCount; layer++) {
                ctx.save();
                ctx.translate(mouseX, mouseY);
                ctx.rotate(time * params.rotationSpeed + (layer * Math.PI / params.circleCount));

                const color = getColor(layer);

                if (params.glowEffect) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = color;
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = params.lineWidth;

                ctx.beginPath();
                for (let i = 0; i < 360 * 3; i++) {
                    const angle = (i * Math.PI / 180);
                    const radius = params.spacing * angle / (2 * Math.PI) + layer * 5;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                ctx.restore();
            }
        }

        function drawLissajous() {
            for (let layer = 0; layer < params.circleCount; layer++) {
                ctx.save();
                ctx.translate(mouseX, mouseY);

                const color = getColor(layer);
                const a = 3 + (layer % 5);
                const b = 2 + (layer % 4);
                const size = params.spacing * (layer + 1);

                if (params.glowEffect) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = color;
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = params.lineWidth;

                ctx.beginPath();
                for (let t = 0; t < Math.PI * 2; t += 0.01) {
                    const x = size * Math.sin(a * t + time * params.rotationSpeed);
                    const y = size * Math.sin(b * t);

                    if (t === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                ctx.restore();
            }
        }

        function getColor(index) {
            if (params.rainbowMode) {
                const hue = (time * 50 + index * (360 / params.circleCount)) % 360;
                return `hsl(${hue}, 100%, 50%)`;
            } else {
                const ratio = index / params.circleCount;
                return interpolateColor(params.mainColor, params.secondColor, ratio);
            }
        }

        function interpolateColor(color1, color2, ratio) {
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);

            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);

            const r = Math.round(r1 + (r2 - r1) * ratio);
            const g = Math.round(g1 + (g2 - g1) * ratio);
            const b = Math.round(b1 + (b2 - b1) * ratio);

            return `rgb(${r}, ${g}, ${b})`;
        }

        function draw() {
            // ÂçäÈÄèÊòé„ÅÆÈªí„Åß„ÇØ„É™„Ç¢Ôºà„Éà„É¨„Ç§„É´ÂäπÊûúÔºâ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, width, height);

            switch (params.patternType) {
                case 'concentric':
                    drawConcentric();
                    break;
                case 'radial':
                    drawRadial();
                    break;
                case 'spiral':
                    drawSpiral();
                    break;
                case 'lissajous':
                    drawLissajous();
                    break;
            }

            time += 0.016;

            // FPSË®àÁÆó
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('fps').textContent = `FPS: ${fps}`;
            }

            requestAnimationFrame(draw);
        }

        // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
        window.addEventListener('resize', resize);
        resize();

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        });

        // „Ç≥„É≥„Éà„É≠„Éº„É´
        document.getElementById('circleCount').addEventListener('input', (e) => {
            params.circleCount = parseInt(e.target.value);
            document.getElementById('circleCountValue').textContent = e.target.value;
        });

        document.getElementById('spacing').addEventListener('input', (e) => {
            params.spacing = parseInt(e.target.value);
            document.getElementById('spacingValue').textContent = e.target.value;
        });

        document.getElementById('lineWidth').addEventListener('input', (e) => {
            params.lineWidth = parseFloat(e.target.value);
            document.getElementById('lineWidthValue').textContent = e.target.value;
        });

        document.getElementById('rotationSpeed').addEventListener('input', (e) => {
            params.rotationSpeed = parseFloat(e.target.value);
            document.getElementById('rotationSpeedValue').textContent = e.target.value;
        });

        document.getElementById('patternType').addEventListener('change', (e) => {
            params.patternType = e.target.value;
        });

        document.getElementById('mainColor').addEventListener('input', (e) => {
            params.mainColor = e.target.value;
        });

        document.getElementById('secondColor').addEventListener('input', (e) => {
            params.secondColor = e.target.value;
        });

        document.getElementById('rainbowMode').addEventListener('change', (e) => {
            params.rainbowMode = e.target.checked;
        });

        document.getElementById('glowEffect').addEventListener('change', (e) => {
            params.glowEffect = e.target.checked;
        });

        document.getElementById('randomize').addEventListener('click', () => {
            params.circleCount = Math.floor(Math.random() * 27) + 3;
            params.spacing = Math.floor(Math.random() * 45) + 5;
            params.rotationSpeed = Math.random() * 2;
            params.patternType = ['concentric', 'radial', 'spiral', 'lissajous'][Math.floor(Math.random() * 4)];
            params.rainbowMode = Math.random() > 0.5;

            document.getElementById('circleCount').value = params.circleCount;
            document.getElementById('circleCountValue').textContent = params.circleCount;
            document.getElementById('spacing').value = params.spacing;
            document.getElementById('spacingValue').textContent = params.spacing;
            document.getElementById('rotationSpeed').value = params.rotationSpeed;
            document.getElementById('rotationSpeedValue').textContent = params.rotationSpeed.toFixed(1);
            document.getElementById('patternType').value = params.patternType;
            document.getElementById('rainbowMode').checked = params.rainbowMode;
        });

        document.getElementById('saveImage').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'moire-pattern.png';
            link.href = canvas.toDataURL();
            link.click();
        });

        document.getElementById('fullscreenBtn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        draw();
    </script>
</body>
</html>
