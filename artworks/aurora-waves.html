<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Aurora Waves - オーロラの波</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .fullscreen-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid rgba(0, 255, 136, 0.5);
            color: #00ff88;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .fullscreen-btn:hover {
            background: rgba(0, 255, 136, 0.3);
            transform: scale(1.05);
        }

        @media (max-width: 768px) {
            .info {
                font-size: 12px;
                top: 10px;
                left: 10px;
            }

            .fullscreen-btn {
                padding: 10px 20px;
                font-size: 14px;
                bottom: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="info">
        <div>Aurora Waves</div>
        <div>移動: オーロラを生成 | クリック: 新しい波</div>
    </div>

    <button class="fullscreen-btn" onclick="toggleFullscreen()">全画面</button>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let mouseX = 0, mouseY = 0;
        let waves = [];

        // 設定
        const WAVE_COUNT = 8;
        const PARTICLES_PER_WAVE = 150;
        const WAVE_SPEED = 0.002;
        const AURORA_COLORS = [
            { r: 0, g: 255, b: 136 },    // グリーン
            { r: 0, g: 200, b: 255 },    // シアン
            { r: 136, g: 0, b: 255 },    // パープル
            { r: 255, g: 0, b: 200 },    // ピンク
            { r: 0, g: 150, b: 255 }     // ブルー
        ];

        class Wave {
            constructor(colorIndex, offsetY) {
                this.colorIndex = colorIndex;
                this.color = AURORA_COLORS[colorIndex];
                this.offsetY = offsetY;
                this.phase = Math.random() * Math.PI * 2;
                this.amplitude = 30 + Math.random() * 50;
                this.frequency = 0.002 + Math.random() * 0.003;
                this.speed = WAVE_SPEED + Math.random() * 0.001;
                this.alpha = 0.3 + Math.random() * 0.4;
                this.particles = [];

                // パーティクル生成
                for (let i = 0; i < PARTICLES_PER_WAVE; i++) {
                    this.particles.push({
                        x: Math.random() * width,
                        baseY: this.offsetY + (Math.random() - 0.5) * 100,
                        size: Math.random() * 2 + 1,
                        alpha: Math.random() * 0.5 + 0.3,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }

            update(time) {
                this.phase += this.speed;

                // マウスの影響
                const dx = mouseX - width / 2;
                const dy = mouseY - height / 2;
                const distToMouse = Math.sqrt(dx * dx + dy * dy);
                const mouseInfluence = Math.max(0, 1 - distToMouse / 500);

                this.particles.forEach(p => {
                    p.phase += this.speed * 0.5;

                    // 複数の波の合成
                    const wave1 = Math.sin(p.x * this.frequency + this.phase + p.phase) * this.amplitude;
                    const wave2 = Math.cos(p.x * this.frequency * 1.5 + this.phase * 0.7) * this.amplitude * 0.5;
                    const wave3 = Math.sin(p.x * this.frequency * 2.3 + this.phase * 1.3) * this.amplitude * 0.3;

                    p.y = p.baseY + wave1 + wave2 + wave3;
                    p.alpha = 0.3 + Math.sin(p.phase + time * 0.001) * 0.2;

                    // マウスによる動き
                    const mousePullX = (mouseX - width / 2) * mouseInfluence * 0.1;
                    const mousePullY = (mouseY - height / 2) * mouseInfluence * 0.1;
                    p.x += mousePullX * 0.01;
                    p.y += mousePullY * 0.01;
                });
            }

            draw(ctx) {
                const { r, g, b } = this.color;

                // グロー効果
                ctx.shadowBlur = 30;
                ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.8)`;

                this.particles.forEach(p => {
                    const gradient = ctx.createRadialGradient(
                        p.x, p.y, 0,
                        p.x, p.y, p.size * 3
                    );
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${p.alpha * this.alpha})`);
                    gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${p.alpha * this.alpha * 0.3})`);
                    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.shadowBlur = 0;
            }
        }

        function init() {
            resize();
            createWaves();
            requestAnimationFrame(animate);
        }

        function createWaves() {
            waves = [];
            const spacing = height / (WAVE_COUNT + 1);

            for (let i = 0; i < WAVE_COUNT; i++) {
                const y = spacing * (i + 1);
                const colorIndex = i % AURORA_COLORS.length;
                waves.push(new Wave(colorIndex, y));
            }
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;

            // ウェーブ再作成
            if (waves.length > 0) {
                createWaves();
            }
        }

        function animate(time) {
            // 背景を暗くしてトレイル効果
            ctx.fillStyle = 'rgba(0, 0, 5, 0.1)';
            ctx.fillRect(0, 0, width, height);

            // グラデーション背景
            const bgGradient = ctx.createRadialGradient(
                width / 2, height / 2, 0,
                width / 2, height / 2, Math.max(width, height)
            );
            bgGradient.addColorStop(0, 'rgba(0, 10, 30, 0.02)');
            bgGradient.addColorStop(1, 'rgba(0, 0, 10, 0.05)');

            waves.forEach(wave => {
                wave.update(time);
                wave.draw(ctx);
            });

            requestAnimationFrame(animate);
        }

        // イベントリスナー
        window.addEventListener('resize', resize);

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        }, { passive: false });

        canvas.addEventListener('click', () => {
            // 新しい波を追加
            const colorIndex = Math.floor(Math.random() * AURORA_COLORS.length);
            waves.push(new Wave(colorIndex, mouseY));

            // 古い波を削除
            if (waves.length > WAVE_COUNT + 3) {
                waves.shift();
            }
        });

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }

        // 初期化
        mouseX = width / 2;
        mouseY = height / 2;
        init();
    </script>
</body>
</html>
