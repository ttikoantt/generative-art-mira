<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perlin Noise Flow Art</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }

        canvas {
            display: block;
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            z-index: 10;
            pointer-events: none;
        }

        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 14px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            z-index: 100;
        }

        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        @media (max-width: 768px) {
            .info {
                font-size: 12px;
                bottom: 10px;
                left: 10px;
            }

            .fullscreen-btn {
                padding: 10px 20px;
                font-size: 12px;
                top: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info">
        <div>Move mouse/touch to interact</div>
    </div>
    <button class="fullscreen-btn" onclick="toggleFullscreen()">â›¶ Fullscreen</button>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let mouseX = 0, mouseY = 0;
        let time = 0;

        // Perlin Noise Implementation
        class PerlinNoise {
            constructor() {
                this.permutation = [];
                for (let i = 0; i < 256; i++) {
                    this.permutation[i] = i;
                }
                // Shuffle
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.permutation[i], this.permutation[j]] = [this.permutation[j], this.permutation[i]];
                }
                // Duplicate for overflow
                this.permutation = [...this.permutation, ...this.permutation];
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;

                x -= Math.floor(x);
                y -= Math.floor(y);

                const u = this.fade(x);
                const v = this.fade(y);

                const A = this.permutation[X] + Y;
                const B = this.permutation[X + 1] + Y;

                return this.lerp(v,
                    this.lerp(u, this.grad(this.permutation[A], x, y), this.grad(this.permutation[B], x - 1, y)),
                    this.lerp(u, this.grad(this.permutation[A + 1], x, y - 1), this.grad(this.permutation[B + 1], x - 1, y - 1))
                );
            }
        }

        const perlin = new PerlinNoise();

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function draw() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            const scale = 0.003;
            const timeScale = 0.0001;

            for (let y = 0; y < height; y += 2) {
                for (let x = 0; x < width; x += 2) {
                    // Distance from mouse for interaction
                    const dx = x - mouseX;
                    const dy = y - mouseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const interaction = Math.max(0, 1 - dist / 300);

                    // Generate noise value
                    let nx = x * scale;
                    let ny = y * scale;
                    let nt = time * timeScale;

                    let noiseValue = perlin.noise(nx + nt, ny + nt) * 0.5 + 0.5;

                    // Add interaction
                    noiseValue += interaction * 0.3;
                    noiseValue = Math.min(1, noiseValue);

                    // Create flowing colors
                    const hue = (noiseValue * 0.5 + time * 0.00005 + interaction * 0.2) % 1;
                    const saturation = 0.7 + interaction * 0.3;
                    const lightness = 0.3 + noiseValue * 0.4;

                    const [r, g, b] = hslToRgb(hue, saturation, lightness);

                    // Set pixels (2x2 for performance)
                    for (let dy = 0; dy < 2 && y + dy < height; dy++) {
                        for (let dx = 0; dx < 2 && x + dx < width; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            data[idx] = r;
                            data[idx + 1] = g;
                            data[idx + 2] = b;
                            data[idx + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function animate() {
            time++;
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        window.addEventListener('resize', resize);

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        });

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // Initialize
        resize();
        mouseX = width / 2;
        mouseY = height / 2;
        animate();
    </script>
</body>
</html>
