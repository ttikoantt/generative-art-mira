<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mandala Generator | ÊõºËçºÁæÖ„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
            touch-action: manipulation;
        }

        #fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        #fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.05);
        }

        h1 {
            color: white;
            font-size: clamp(24px, 5vw, 42px);
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            text-align: center;
            padding: 0 20px;
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.7);
            font-size: clamp(12px, 3vw, 16px);
            margin-bottom: 30px;
            text-align: center;
        }

        #mandala-canvas {
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            background: black;
            cursor: pointer;
            touch-action: none;
        }

        .controls {
            margin-top: 30px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            padding: 0 20px;
            max-width: 600px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        input[type="range"] {
            width: 120px;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        button {
            padding: 15px 35px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 30px;
            color: white;
            font-size: clamp(14px, 3vw, 16px);
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
        }

        @media (max-width: 768px) {
            h1 {
                margin-bottom: 15px;
            }

            .subtitle {
                margin-bottom: 20px;
            }

            .controls {
                margin-top: 20px;
                gap: 10px;
            }

            input[type="range"] {
                width: 100px;
            }

            button {
                padding: 12px 28px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <button id="fullscreen-btn">üì∫ ÂÖ®ÁîªÈù¢</button>

    <h1>‚ú® Mandala Generator</h1>
    <p class="subtitle">ÊõºËçºÁæÖ„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº - „ÇØ„É™„ÉÉ„ÇØ„ÅßÊñ∞„Åó„ÅÑ„Éë„Çø„Éº„É≥ÁîüÊàê</p>

    <canvas id="mandala-canvas"></canvas>

    <div class="controls">
        <div class="control-group">
            <label>„Çª„Ç∞„É°„É≥„ÉàÊï∞: <span id="segments-value">12</span></label>
            <input type="range" id="segments" min="6" max="24" value="12">
        </div>

        <div class="control-group">
            <label>Ë§áÈõë„Åï: <span id="complexity-value">5</span></label>
            <input type="range" id="complexity" min="3" max="10" value="5">
        </div>

        <div class="control-group">
            <label>Ëâ≤„ÅÆÈÆÆ„ÇÑ„Åã„Åï: <span id="saturation-value">80</span></label>
            <input type="range" id="saturation" min="30" max="100" value="80">
        </div>

        <button id="generate-btn">üé® Êñ∞„Åó„ÅÑÊõºËçºÁæÖ</button>
    </div>

    <div class="info">Tap canvas or button to generate</div>

    <script>
        const canvas = document.getElementById('mandala-canvas');
        const ctx = canvas.getContext('2d');

        // Controls
        const segmentsInput = document.getElementById('segments');
        const complexityInput = document.getElementById('complexity');
        const saturationInput = document.getElementById('saturation');
        const generateBtn = document.getElementById('generate-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');

        // Update display values
        segmentsInput.addEventListener('input', (e) => {
            document.getElementById('segments-value').textContent = e.target.value;
            generateMandala();
        });

        complexityInput.addEventListener('input', (e) => {
            document.getElementById('complexity-value').textContent = e.target.value;
            generateMandala();
        });

        saturationInput.addEventListener('input', (e) => {
            document.getElementById('saturation-value').textContent = e.target.value;
            generateMandala();
        });

        // Responsive canvas sizing
        function resizeCanvas() {
            const size = Math.min(window.innerWidth - 60, window.innerHeight - 350, 500);
            const displaySize = Math.max(size, 280);
            canvas.width = displaySize;
            canvas.height = displaySize;
            generateMandala();
        }

        // HSL to RGB conversion
        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        // Generate mandala pattern
        function generateMandala() {
            const segments = parseInt(segmentsInput.value);
            const complexity = parseInt(complexityInput.value);
            const saturation = parseInt(saturationInput.value) / 100;

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(centerX, centerY) * 0.95;

            // Generate random parameters for this mandala
            const baseHue = Math.random() * 360;
            const patternType = Math.floor(Math.random() * 4);

            // Draw mandala
            for (let layer = 0; layer < complexity; layer++) {
                const layerRadius = (maxRadius / complexity) * (layer + 1);
                const hue = (baseHue + layer * 30) % 360;
                const lightness = 0.4 + (layer * 0.05);

                for (let i = 0; i < segments; i++) {
                    const angle = (2 * Math.PI / segments) * i;
                    const nextAngle = (2 * Math.PI / segments) * (i + 1);
                    const midAngle = (angle + nextAngle) / 2;

                    ctx.save();
                    ctx.translate(centerX, centerY);

                    // Draw different pattern types
                    switch (patternType) {
                        case 0: // Petal pattern
                            ctx.beginPath();
                            ctx.moveTo(0, 0);

                            const cp1x = Math.cos(angle) * layerRadius * 0.3;
                            const cp1y = Math.sin(angle) * layerRadius * 0.3;
                            const cp2x = Math.cos(midAngle) * layerRadius;
                            const cp2y = Math.sin(midAngle) * layerRadius;
                            const endx = Math.cos(nextAngle) * layerRadius * 0.3;
                            const endy = Math.sin(nextAngle) * layerRadius * 0.3;

                            ctx.quadraticCurveTo(cp2x, cp2y, endx, endy);
                            ctx.lineTo(0, 0);

                            const [r, g, b] = hslToRgb(hue / 360, saturation, lightness);
                            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.6 - layer * 0.05})`;
                            ctx.fill();
                            ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 - layer * 0.02})`;
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                            break;

                        case 1: // Star pattern
                            ctx.beginPath();
                            const innerR = layerRadius * (0.3 + (layer % 2) * 0.2);
                            const outerR = layerRadius * (0.7 - (layer % 2) * 0.2);

                            for (let j = 0; j <= 4; j++) {
                                const starAngle = angle + (nextAngle - angle) * (j / 4);
                                const radius = j % 2 === 0 ? outerR : innerR;
                                const x = Math.cos(starAngle) * radius;
                                const y = Math.sin(starAngle) * radius;

                                if (j === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            }

                            ctx.closePath();
                            const [sr, sg, sb] = hslToRgb(hue / 360, saturation, lightness);
                            ctx.fillStyle = `rgba(${sr}, ${sg}, ${sb}, ${0.7 - layer * 0.05})`;
                            ctx.fill();
                            ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 - layer * 0.03})`;
                            ctx.lineWidth = 0.8;
                            ctx.stroke();
                            break;

                        case 2: // Circle pattern
                            for (let j = 0; j < 3; j++) {
                                const circleAngle = angle + (nextAngle - angle) * ((j + 1) / 4);
                                const circleRadius = layerRadius * (0.2 + j * 0.15);
                                const circleX = Math.cos(circleAngle) * circleRadius;
                                const circleY = Math.sin(circleAngle) * circleRadius;

                                ctx.beginPath();
                                ctx.arc(circleX, circleY, layerRadius * 0.15, 0, 2 * Math.PI);

                                const circleHue = (hue + j * 20) % 360;
                                const [cr, cg, cb] = hslToRgb(circleHue / 360, saturation, lightness);
                                ctx.fillStyle = `rgba(${cr}, ${cg}, ${cb}, ${0.7 - layer * 0.05})`;
                                ctx.fill();
                                ctx.strokeStyle = `rgba(255, 255, 255, 0.3)`;
                                ctx.lineWidth = 0.5;
                                ctx.stroke();
                            }
                            break;

                        case 3: // Geometric pattern
                            ctx.beginPath();
                            ctx.moveTo(0, 0);

                            for (let j = 0; j <= 3; j++) {
                                const geoAngle = angle + (nextAngle - angle) * (j / 3);
                                const geoRadius = layerRadius * (0.8 - j * 0.15);
                                const gx = Math.cos(geoAngle) * geoRadius;
                                const gy = Math.sin(geoAngle) * geoRadius;
                                ctx.lineTo(gx, gy);
                            }

                            ctx.closePath();
                            const [gr, gg, gb] = hslToRgb((hue + layer * 15) / 360, saturation, lightness);
                            ctx.fillStyle = `rgba(${gr}, ${gg}, ${gb}, ${0.6 - layer * 0.05})`;
                            ctx.fill();
                            ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 - layer * 0.02})`;
                            ctx.lineWidth = 0.6;
                            ctx.stroke();
                            break;
                    }

                    ctx.restore();
                }

                // Add decorative dots
                if (layer < complexity - 1) {
                    for (let i = 0; i < segments; i++) {
                        const dotAngle = (2 * Math.PI / segments) * i + (layer * Math.PI / segments);
                        const dotRadius = layerRadius * 1.1;
                        const dotX = centerX + Math.cos(dotAngle) * dotRadius;
                        const dotY = centerY + Math.sin(dotAngle) * dotRadius;

                        ctx.beginPath();
                        ctx.arc(dotX, dotY, 3, 0, 2 * Math.PI);
                        const [dr, dg, db] = hslToRgb((baseHue + layer * 40) / 360, saturation, 0.8);
                        ctx.fillStyle = `rgba(${dr}, ${dg}, ${db}, 0.9)`;
                        ctx.fill();
                    }
                }
            }

            // Center decoration
            ctx.beginPath();
            ctx.arc(centerX, centerY, maxRadius * 0.08, 0, 2 * Math.PI);
            const [cr, cg, cb] = hslToRgb(baseHue / 360, saturation, 0.7);
            ctx.fillStyle = `rgba(${cr}, ${cg}, ${cb}, 0.9)`;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Outer glow
            const gradient = ctx.createRadialGradient(centerX, centerY, maxRadius * 0.5, centerX, centerY, maxRadius);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, `rgba(${cr}, ${cg}, ${cb}, 0.1)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Event listeners
        canvas.addEventListener('click', generateMandala);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            generateMandala();
        });

        generateBtn.addEventListener('click', generateMandala);

        // Fullscreen
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Auto-generate on load
        setTimeout(generateMandala, 100);
    </script>
</body>
</html>
