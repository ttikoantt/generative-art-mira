<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorenz Attractor - Chaos Theory Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        .info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .info h1 {
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 5px;
            color: #fff;
        }

        .info p {
            margin: 3px 0;
            font-size: 12px;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .controls button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .controls button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div class="info">
        <h1>ðŸ¦‹ Lorenz Attractor</h1>
        <p>Chaos Theory Visualization</p>
        <p>Drag to rotate â€¢ Scroll to zoom</p>
    </div>

    <button class="fullscreen-btn" id="fullscreenBtn">â›¶</button>

    <div class="controls">
        <button id="resetBtn">ðŸ”„ Reset</button>
        <button id="colorBtn">ðŸŽ¨ Colors</button>
        <button id="speedBtn">âš¡ Speed</button>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Canvas setup
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Lorenz Attractor parameters
        const sigma = 10;
        const rho = 28;
        const beta = 8 / 3;

        // Point storage
        const maxPoints = 5000;
        let points = [];

        // 3D rotation
        let rotationX = 0.5;
        let rotationY = 0.5;
        let zoom = 1;

        // Color schemes
        const colorSchemes = [
            // Rainbow
            (t) => `hsl(${(t * 360) % 360}, 80%, 60%)`,
            // Fire
            (t) => `hsl(${20 + t * 30}, 100%, ${40 + t * 30}%)`,
            // Ocean
            (t) => `hsl(${180 + t * 60}, 80%, ${40 + t * 30}%)`,
            // Neon
            (t) => `hsl(${280 + t * 80}, 100%, 60%)`,
            // Monochrome
            (t) => `hsl(0, 0%, ${30 + t * 60}%)`
        ];

        let currentColorScheme = 0;
        let speed = 1;

        // Initialize points
        function initPoints() {
            points = [];
            let x = 0.1, y = 0, z = 0;
            const dt = 0.005;

            // Pre-compute points
            for (let i = 0; i < maxPoints; i++) {
                const dx = sigma * (y - x) * dt;
                const dy = (x * (rho - z) - y) * dt;
                const dz = (x * y - beta * z) * dt;

                x += dx;
                y += dy;
                z += dz;

                points.push({ x, y, z });
            }
        }

        // 3D to 2D projection
        function project(x, y, z) {
            // Apply rotation
            const cosX = Math.cos(rotationX);
            const sinX = Math.sin(rotationX);
            const cosY = Math.cos(rotationY);
            const sinY = Math.sin(rotationY);

            // Rotate around Y axis
            let x1 = x * cosY - z * sinY;
            let z1 = x * sinY + z * cosY;

            // Rotate around X axis
            let y1 = y * cosX - z1 * sinX;
            let z2 = y * sinX + z1 * cosX;

            // Perspective projection
            const scale = 800 * zoom;
            const perspective = 3 / (4 - z2 / 50);

            return {
                x: canvas.width / 2 + x1 * scale * perspective / 50,
                y: canvas.height / 2 - y1 * scale * perspective / 50
            };
        }

        // Draw
        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const projected = points.map((p, i) => {
                const proj = project(p.x, p.y, p.z);
                return {
                    x: proj.x,
                    y: proj.y,
                    t: i / maxPoints
                };
            });

            // Draw lines
            ctx.lineWidth = 1.5;
            const colorFunc = colorSchemes[currentColorScheme];

            for (let i = 1; i < projected.length; i++) {
                const alpha = i / projected.length;
                ctx.strokeStyle = colorFunc(projected[i].t);
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.moveTo(projected[i - 1].x, projected[i - 1].y);
                ctx.lineTo(projected[i].x, projected[i].y);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        // Animation
        let time = 0;
        function animate() {
            time += 0.01 * speed;

            // Auto-rotate
            rotationY += 0.002 * speed;

            draw();
            requestAnimationFrame(animate);
        }

        // Mouse controls
        let isDragging = false;
        let lastX, lastY;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;

            rotationY += dx * 0.01;
            rotationX += dy * 0.01;

            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);

        // Touch controls
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDragging) return;

            const dx = e.touches[0].clientX - lastX;
            const dy = e.touches[0].clientY - lastY;

            rotationY += dx * 0.01;
            rotationX += dy * 0.01;

            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchend', () => isDragging = false);

        // Zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom *= e.deltaY > 0 ? 0.95 : 1.05;
            zoom = Math.max(0.1, Math.min(5, zoom));
        });

        // Buttons
        document.getElementById('resetBtn').addEventListener('click', () => {
            rotationX = 0.5;
            rotationY = 0.5;
            zoom = 1;
        });

        document.getElementById('colorBtn').addEventListener('click', () => {
            currentColorScheme = (currentColorScheme + 1) % colorSchemes.length;
        });

        document.getElementById('speedBtn').addEventListener('click', () => {
            speed = speed === 1 ? 2 : speed === 2 ? 0.5 : 1;
        });

        // Fullscreen
        document.getElementById('fullscreenBtn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        // Initialize and start
        initPoints();
        animate();
    </script>
</body>
</html>
