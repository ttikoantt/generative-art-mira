<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Dreamscape - „Éï„É©„ÇØ„Çø„É´Â§¢Â¢É</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .ui h1 {
            font-size: 16px;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .ui p {
            margin: 5px 0;
            opacity: 0.8;
        }

        .ui .controls {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .ui .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 3px;
            margin: 2px;
            font-size: 10px;
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 5px;
            backdrop-filter: blur(5px);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .loading.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="ui">
        <h1>üåÄ Fractal Dreamscape</h1>
        <p>„Éï„É©„ÇØ„Çø„É´„ÅÆÁÑ°Èôê„ÅÆ‰∏ñÁïå„ÇíÊé¢Á¥¢</p>
        <div class="controls">
            <div><span class="key">„Éâ„É©„ÉÉ„Ç∞</span> „Éë„É≥</div>
            <div><span class="key">„Çπ„ÇØ„É≠„Éº„É´</span> „Ç∫„Éº„É†</div>
            <div><span class="key">C</span> „Ç´„É©„ÉºÂ§âÊõ¥</div>
            <div><span class="key">F</span> „Éï„É©„ÇØ„Çø„É´ÂàáÊõø</div>
            <div><span class="key">A</span> „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥</div>
            <div><span class="key">R</span> „É™„Çª„ÉÉ„Éà</div>
            <div><span class="key">S</span> ‰øùÂ≠ò</div>
        </div>
    </div>

    <div class="info" id="info">
        Zoom: 1.00x | Center: (0.00, 0.00) | Fractal: Mandelbrot
    </div>

    <div class="loading" id="loading">Ë®àÁÆó‰∏≠...</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const info = document.getElementById('info');
        const loading = document.getElementById('loading');

        // Ë®≠ÂÆö
        let width, height;
        let maxIterations = 100;
        let zoom = 1;
        let centerX = 0;
        let centerY = 0;
        let colorScheme = 0;
        let fractalType = 0; // 0: Mandelbrot, 1: Julia
        let animating = false;
        let animationTime = 0;

        // JuliaÈõÜÂêà„ÅÆ„Éë„É©„É°„Éº„Çø
        let juliaC = { real: -0.7, imag: 0.27015 };

        // „Ç´„É©„Éº„Éë„É¨„ÉÉ„Éà
        const colorSchemes = [
            { name: 'Rainbow', colors: ['#000033', '#000066', '#0000FF', '#00FFFF', '#00FF00', '#FFFF00', '#FF8000', '#FF0000'] },
            { name: 'Ocean', colors: ['#000011', '#000033', '#000066', '#0000AA', '#0033CC', '#0066FF', '#00AAFF', '#00DDFF'] },
            { name: 'Fire', colors: ['#000000', '#330000', '#660000', '#AA0000', '#FF0000', '#FF6600', '#FFAA00', '#FFDD00'] },
            { name: 'Forest', colors: ['#001100', '#002200', '#004400', '#006600', '#008800', '#00AA00', '#00CC00', '#00EE00'] },
            { name: 'Purple', colors: ['#110022', '#220044', '#440088', '#6600AA', '#8800CC', '#AA00DD', '#CC00EE', '#DD00FF'] },
            { name: 'Sunset', colors: ['#220011', '#440022', '#880044', '#AA0066', '#CC0088', '#DD00AA', '#EE00CC', '#FF00DD'] },
            { name: 'Monochrome', colors: ['#000000', '#111111', '#222222', '#444444', '#666666', '#888888', '#AAAAAA', '#CCCCCC'] },
            { name: 'Neon', colors: ['#000000', '#FF00FF', '#00FFFF', '#FF0088', '#00FF88', '#8800FF', '#FF8800', '#00FF00'] }
        ];

        // „Éû„Ç¶„ÇπÁä∂ÊÖã
        let isDragging = false;
        let lastMouseX, lastMouseY;

        // ÂàùÊúüÂåñ
        function init() {
            resize();
            window.addEventListener('resize', resize);
            setupEventListeners();
            render();
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            render();
        }

        function setupEventListeners() {
            // „Éû„Ç¶„Çπ„Éâ„É©„ÉÉ„Ç∞„Åß„Éë„É≥
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - lastMouseX;
                    const dy = e.clientY - lastMouseY;
                    centerX -= dx / (200 * zoom);
                    centerY -= dy / (200 * zoom);
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    render();
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
            });

            // „Çπ„ÇØ„É≠„Éº„É´„Åß„Ç∫„Éº„É†
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                zoom *= zoomFactor;
                zoom = Math.max(0.1, Math.min(zoom, 1000000));
                render();
            });

            // „Ç≠„Éº„Éú„Éº„ÉâÊìç‰Ωú
            document.addEventListener('keydown', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'c':
                        colorScheme = (colorScheme + 1) % colorSchemes.length;
                        render();
                        break;
                    case 'f':
                        fractalType = (fractalType + 1) % 2;
                        render();
                        break;
                    case 'a':
                        animating = !animating;
                        if (animating) {
                            animate();
                        }
                        break;
                    case 'r':
                        zoom = 1;
                        centerX = 0;
                        centerY = 0;
                        juliaC = { real: -0.7, imag: 0.27015 };
                        render();
                        break;
                    case 's':
                        saveImage();
                        break;
                }
            });

            // „Çø„ÉÉ„ÉÅÊìç‰Ωú
            let lastTouchDist = 0;
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    lastTouchDist = Math.sqrt(dx * dx + dy * dy);
                }
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1 && isDragging) {
                    const dx = e.touches[0].clientX - lastMouseX;
                    const dy = e.touches[0].clientY - lastMouseY;
                    centerX -= dx / (200 * zoom);
                    centerY -= dy / (200 * zoom);
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                    render();
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (lastTouchDist > 0) {
                        const zoomFactor = dist / lastTouchDist;
                        zoom *= zoomFactor;
                        zoom = Math.max(0.1, Math.min(zoom, 1000000));
                        render();
                    }
                    lastTouchDist = dist;
                }
            });

            canvas.addEventListener('touchend', () => {
                isDragging = false;
                lastTouchDist = 0;
            });
        }

        function getColor(iteration, maxIter) {
            if (iteration === maxIter) {
                return [0, 0, 0];
            }

            const scheme = colorSchemes[colorScheme].colors;
            const t = iteration / maxIter;
            const pos = t * (scheme.length - 1);
            const i = Math.floor(pos);
            const f = pos - i;

            const color1 = hexToRgb(scheme[Math.min(i, scheme.length - 1)]);
            const color2 = hexToRgb(scheme[Math.min(i + 1, scheme.length - 1)]);

            return [
                Math.floor(color1.r + (color2.r - color1.r) * f),
                Math.floor(color1.g + (color2.g - color1.g) * f),
                Math.floor(color1.b + (color2.b - color1.b) * f)
            ];
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function mandelbrot(cReal, cImag, maxIter) {
            let zReal = 0;
            let zImag = 0;
            let n = 0;

            while (n < maxIter && (zReal * zReal + zImag * zImag) <= 4) {
                const tempReal = zReal * zReal - zImag * zImag + cReal;
                zImag = 2 * zReal * zImag + cImag;
                zReal = tempReal;
                n++;
            }

            return n;
        }

        function julia(zReal, zImag, cReal, cImag, maxIter) {
            let n = 0;

            while (n < maxIter && (zReal * zReal + zImag * zImag) <= 4) {
                const tempReal = zReal * zReal - zImag * zImag + cReal;
                zImag = 2 * zReal * zImag + cImag;
                zReal = tempReal;
                n++;
            }

            return n;
        }

        function render() {
            loading.classList.add('show');

            setTimeout(() => {
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;

                for (let px = 0; px < width; px++) {
                    for (let py = 0; py < height; py++) {
                        const x = (px - width / 2) / (200 * zoom) + centerX;
                        const y = (py - height / 2) / (200 * zoom) + centerY;

                        let iteration;
                        if (fractalType === 0) {
                            iteration = mandelbrot(x, y, maxIterations);
                        } else {
                            iteration = julia(x, y, juliaC.real, juliaC.imag, maxIterations);
                        }

                        const color = getColor(iteration, maxIterations);
                        const index = (py * width + px) * 4;

                        data[index] = color[0];
                        data[index + 1] = color[1];
                        data[index + 2] = color[2];
                        data[index + 3] = 255;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                updateInfo();
                loading.classList.remove('show');
            }, 10);
        }

        function updateInfo() {
            const fractalName = fractalType === 0 ? 'Mandelbrot' : 'Julia';
            const colorName = colorSchemes[colorScheme].name;
            info.textContent = `Zoom: ${zoom.toFixed(2)}x | Center: (${centerX.toFixed(4)}, ${centerY.toFixed(4)}) | Fractal: ${fractalName} | Color: ${colorName}`;
        }

        function animate() {
            if (!animating) return;

            animationTime += 0.02;

            // JuliaÈõÜÂêà„Çí„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
            if (fractalType === 1) {
                juliaC.real = -0.7 + Math.sin(animationTime) * 0.1;
                juliaC.imag = 0.27015 + Math.cos(animationTime * 1.3) * 0.1;
                render();
            }

            // „Ç´„É©„Éº„Çí„Ç∑„Éï„Éà
            if (Math.floor(animationTime * 10) % 5 === 0) {
                colorScheme = (colorScheme + 1) % colorSchemes.length;
            }

            requestAnimationFrame(animate);
        }

        function saveImage() {
            const link = document.createElement('a');
            link.download = `fractal-dreamscape-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        // ÈñãÂßã
        init();
    </script>
</body>
</html>
