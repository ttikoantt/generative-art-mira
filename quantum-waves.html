<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Wave Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            overflow: hidden;
        }

        #canvas {
            display: block;
            cursor: crosshair;
        }

        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #0ff;
            font-size: 14px;
            pointer-events: none;
            text-shadow: 0 0 10px #0ff;
            opacity: 0.8;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90%;
        }

        .control-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 10px 20px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            transition: all 0.3s;
            pointer-events: auto;
        }

        .control-btn:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 20px #0ff;
        }

        #fullscreen {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        <div>Quantum Wave Function Ψ(x,t)</div>
        <div id="stats"></div>
    </div>
    <div id="controls">
        <button class="control-btn" onclick="changePattern(0)">Single Wave</button>
        <button class="control-btn" onclick="changePattern(1)">Superposition</button>
        <button class="control-btn" onclick="changePattern(2)">Interference</button>
        <button class="control-btn" onclick="changePattern(3)">Tunneling</button>
        <button class="control-btn" onclick="togglePause()">Pause/Play</button>
    </div>
    <button id="fullscreen" class="control-btn" onclick="toggleFullscreen()">⛶</button>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const stats = document.getElementById('stats');

        let width, height;
        let time = 0;
        let paused = false;
        let mouseX = 0, mouseY = 0;
        let pattern = 1;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resize);
        resize();

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        });

        function waveFunction(x, t, k, omega, phase) {
            return Math.sin(k * x - omega * t + phase);
        }

        function gaussian(x, mu, sigma) {
            return Math.exp(-Math.pow(x - mu, 2) / (2 * sigma * sigma));
        }

        function quantumPacket(x, t, k0, sigma) {
            const groupVelocity = k0 * 0.5;
            const center = x - groupVelocity * t;
            const envelope = gaussian(x, width / 2 + center, sigma);
            const phase = k0 * x - k0 * k0 * 0.25 * t;
            return envelope * Math.cos(phase);
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);

            const centerY = height / 2;
            const amplitude = Math.min(height * 0.3, 150);
            const wavelength = width / (3 + Math.sin(time * 0.001) * 1);

            stats.innerHTML = `Pattern: ${['Single', 'Superposition', 'Interference', 'Tunneling'][pattern]}<br>` +
                            `Time: ${time.toFixed(2)}<br>` +
                            `Wavelength: ${wavelength.toFixed(1)}px`;

            ctx.lineWidth = 2;

            // 複数の波動関数を描画
            for (let wave = 0; wave < 3; wave++) {
                ctx.beginPath();

                const hue = (time * 0.05 + wave * 120) % 360;
                const saturation = 80 + Math.sin(time * 0.01 + wave) * 20;
                const lightness = 50 + Math.sin(time * 0.02 + wave * 2) * 10;

                ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.8)`;
                ctx.shadowColor = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.5)`;
                ctx.shadowBlur = 10;

                for (let x = 0; x < width; x++) {
                    let y = centerY;

                    switch (pattern) {
                        case 0: // Single Wave
                            y += waveFunction(x, time * 0.02, 0.02, 1, wave * Math.PI / 3) * amplitude;
                            break;

                        case 1: // Superposition
                            y += waveFunction(x, time * 0.02, 0.02, 1, wave * Math.PI / 3) * amplitude * 0.5;
                            y += waveFunction(x, time * 0.03, 0.04, 1.5, wave * Math.PI / 2) * amplitude * 0.3;
                            break;

                        case 2: // Interference
                            const dist1 = Math.sqrt(Math.pow(x - width * 0.3, 2) + Math.pow(mouseY - centerY, 2));
                            const dist2 = Math.sqrt(Math.pow(x - width * 0.7, 2) + Math.pow(mouseY - centerY, 2));
                            y += Math.sin(dist1 * 0.02 - time * 0.05) * amplitude * 0.5 * gaussian(x, width * 0.3, 100);
                            y += Math.sin(dist2 * 0.02 - time * 0.05) * amplitude * 0.5 * gaussian(x, width * 0.7, 100);
                            break;

                        case 3: // Tunneling
                            const barrierX = width * 0.5;
                            const barrierWidth = 50;
                            const tunneling = x < barrierX ? 1 : Math.exp(-(x - barrierX) / 100);
                            y += quantumPacket(x, time * 0.01, 0.03, 80) * amplitude * tunneling;
                            break;
                    }

                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.stroke();
            }

            // 粒子の確率密度を描画
            if (pattern === 3) {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
                for (let x = 0; x < width; x += 5) {
                    const psi = quantumPacket(x, time * 0.01, 0.03, 80);
                    const probability = psi * psi;
                    const h = probability * amplitude * 2;
                    ctx.fillRect(x, centerY + amplitude - h / 2, 5, h);
                }
            }

            // バリア描画（トンネリング効果）
            if (pattern === 3) {
                const barrierX = width * 0.5;
                ctx.fillStyle = 'rgba(255, 0, 100, 0.3)';
                ctx.fillRect(barrierX, centerY - amplitude, 50, amplitude * 2);
                ctx.strokeStyle = 'rgba(255, 0, 100, 0.8)';
                ctx.strokeRect(barrierX, centerY - amplitude, 50, amplitude * 2);
            }

            if (!paused) {
                time++;
            }

            requestAnimationFrame(draw);
        }

        function changePattern(p) {
            pattern = p;
        }

        function togglePause() {
            paused = !paused;
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // キーボード操作
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') {
                togglePause();
            } else if (e.key >= '0' && e.key <= '3') {
                changePattern(parseInt(e.key));
            } else if (e.key === 'f') {
                toggleFullscreen();
            }
        });

        draw();
    </script>
</body>
</html>
