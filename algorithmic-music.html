<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Ç¢„É´„Ç¥„É™„Ç∫„É†Èü≥Ê•Ω - „Éï„Ç£„Éú„Éä„ÉÉ„ÉÅÊï∞Âàó</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            width: 100%;
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #888;
            margin-bottom: 40px;
            font-size: 1.1rem;
        }

        .visualization {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        canvas {
            width: 100%;
            height: 300px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
        }

        .info {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info h2 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #00d9ff;
        }

        .fibonacci {
            font-size: 0.9rem;
            color: #aaa;
            word-wrap: break-word;
            line-height: 1.6;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #00d9ff, #00ff88);
            border: none;
            border-radius: 50px;
            padding: 15px 40px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(0, 217, 255, 0.4);
        }

        button:active {
            transform: scale(0.98);
        }

        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .subtitle {
                font-size: 0.9rem;
            }

            button {
                padding: 12px 30px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <button class="fullscreen-btn" onclick="toggleFullscreen()">ÂÖ®ÁîªÈù¢</button>

    <div class="container">
        <h1>üéµ „Ç¢„É´„Ç¥„É™„Ç∫„É†Èü≥Ê•Ω</h1>
        <p class="subtitle">„Éï„Ç£„Éú„Éä„ÉÉ„ÉÅÊï∞Âàó„Åã„ÇâÁîüÊàê„Åï„Çå„ÅüÈü≥Ê•Ω</p>

        <div class="visualization">
            <canvas id="visualizer"></canvas>
        </div>

        <div class="info">
            <h2>„Éï„Ç£„Éú„Éä„ÉÉ„ÉÅÊï∞Âàó ‚Üí Èü≥Á¨¶</h2>
            <p class="fibonacci" id="sequence"></p>
        </div>

        <div class="controls">
            <button onclick="playMusic()">‚ñ∂ ÂÜçÁîü</button>
            <button onclick="stopMusic()">‚èπ ÂÅúÊ≠¢</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');

        // Canvas size
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Note frequencies
        const NOTE_FREQUENCIES = {
            'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F3': 174.61, 'G3': 196.00, 'A3': 220.00, 'B3': 246.94,
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
            'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46, 'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
        };

        const noteNames = Object.keys(NOTE_FREQUENCIES);

        // Fibonacci sequence
        function fibonacciSequence(n) {
            const seq = [0, 1];
            for (let i = 2; i < n; i++) {
                seq.push(seq[i-1] + seq[i-2]);
            }
            return seq;
        }

        // Fibonacci to notes
        function fibonacciToNotes(fibSeq) {
            return fibSeq.map(num => noteNames[num % noteNames.length]);
        }

        // Generate sequence
        const fibSeq = fibonacciSequence(30);
        const notes = fibonacciToNotes(fibSeq);

        // Display sequence
        document.getElementById('sequence').textContent =
            `„Éï„Ç£„Éú„Éä„ÉÉ„ÉÅ: ${fibSeq.slice(0, 15).join(', ')}...\n` +
            `Èü≥Á¨¶: ${notes.slice(0, 15).join(', ')}...`;

        // Audio context
        let audioCtx = null;
        let isPlaying = false;
        let currentNote = 0;
        let animationId = null;

        // Visualization
        let particles = [];
        const colors = ['#00d9ff', '#00ff88', '#ff6b6b', '#ffd93d', '#6bcb77'];

        class Particle {
            constructor(x, y, noteIndex) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 20 + 10;
                this.speedX = (Math.random() - 0.5) * 3;
                this.speedY = (Math.random() - 0.5) * 3;
                this.color = colors[noteIndex % colors.length];
                this.alpha = 1;
                this.decay = Math.random() * 0.02 + 0.01;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.alpha -= this.decay;
                this.size *= 0.98;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.alpha <= 0;
            }
        }

        function createParticles(x, y, count, noteIndex) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, noteIndex));
            }
        }

        function draw() {
            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);

            // Update and draw particles
            particles = particles.filter(p => !p.isDead());
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            // Draw current note info
            if (isPlaying && currentNote < notes.length) {
                const note = notes[currentNote];
                const freq = NOTE_FREQUENCIES[note];

                ctx.save();
                ctx.font = 'bold 24px Courier New';
                ctx.fillStyle = colors[currentNote % colors.length];
                ctx.textAlign = 'center';
                ctx.fillText(`‚ô™ ${note} (${freq.toFixed(1)} Hz)`, width / 2, 50);
                ctx.restore();

                // Progress bar
                const progress = (currentNote + 1) / notes.length;
                ctx.fillStyle = colors[currentNote % colors.length];
                ctx.fillRect(0, height - 5, width * progress, 5);
            }

            animationId = requestAnimationFrame(draw);
        }

        draw();

        // Play tone
        function playTone(frequency, startTime, duration) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = 'sine';
            oscillator.frequency.value = frequency;

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = startTime;
            const attackTime = 0.05;
            const releaseTime = 0.1;

            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.3, now + attackTime);
            gainNode.gain.setValueAtTime(0.3, now + duration - releaseTime);
            gainNode.gain.linearRampToValueAtTime(0, now + duration);

            oscillator.start(now);
            oscillator.stop(now + duration);
        }

        // Play music
        function playMusic() {
            if (isPlaying) return;

            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            isPlaying = true;
            currentNote = 0;

            const noteDuration = 0.25;
            const pauseDuration = 0.05;
            const startTime = audioCtx.currentTime + 0.1;

            notes.forEach((note, index) => {
                const time = startTime + index * (noteDuration + pauseDuration);
                playTone(NOTE_FREQUENCIES[note], time, noteDuration);

                // Schedule visualization
                setTimeout(() => {
                    currentNote = index;
                    const width = canvas.offsetWidth;
                    const height = canvas.offsetHeight;
                    createParticles(width / 2, height / 2, 10, index);
                }, (time - audioCtx.currentTime) * 1000);
            });

            // Reset after playing
            setTimeout(() => {
                isPlaying = false;
                currentNote = 0;
            }, notes.length * (noteDuration + pauseDuration) * 1000);
        }

        function stopMusic() {
            if (audioCtx) {
                audioCtx.close();
                audioCtx = null;
            }
            isPlaying = false;
            currentNote = 0;
            particles = [];
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
    </script>
</body>
</html>
